// Package ast provides real-world validation tests
// Complies with CODING_STANDARDS.md: Tests max 500 lines
package ast

import (
	"os"
	"path/filepath"
	"testing"
)

// TestValidationAgainstRealCodebase tests validation against actual project files
func TestValidationAgainstRealCodebase(t *testing.T) {
	// Get project root (assuming we're in hub/api/ast)
	projectRoot := "../../../.."
	if _, err := os.Stat(projectRoot); err != nil {
		t.Skip("Project root not found, skipping real-world test")
	}

	// Test files from the project
	testFiles := []struct {
		path     string
		language string
	}{
		{"internal/cli/cli.go", "go"},
		{"hub/api/ast/analysis.go", "go"},
		{"hub/api/ast/validator.go", "go"},
	}

	for _, testFile := range testFiles {
		fullPath := filepath.Join(projectRoot, testFile.path)
		if _, err := os.Stat(fullPath); err != nil {
			continue // Skip if file doesn't exist
		}

		code, err := os.ReadFile(fullPath)
		if err != nil {
			t.Logf("Failed to read %s: %v", testFile.path, err)
			continue
		}

		// Run analysis with validation
		findings, _, err := AnalyzeASTWithValidation(
			string(code),
			testFile.language,
			testFile.path,
			projectRoot,
			[]string{"orphaned", "unused"},
		)

		if err != nil {
			t.Logf("Analysis failed for %s: %v", testFile.path, err)
			continue
		}

		// Verify findings have proper metadata
		for _, finding := range findings {
			if !finding.Validated {
				t.Errorf("Finding %s in %s was not validated", finding.Type, testFile.path)
			}
			if finding.Confidence < 0 || finding.Confidence > 1.0 {
				t.Errorf("Invalid confidence %.2f for finding in %s", finding.Confidence, testFile.path)
			}
		}
	}
}

// TestKnownEdgeCases tests validation with known edge case scenarios
func TestKnownEdgeCases(t *testing.T) {
	tmpDir := t.TempDir()
	projectRoot := tmpDir

	tests := []struct {
		name     string
		code     string
		language string
		file     string
		expect   string // "low_confidence" or "high_confidence"
	}{
		{
			name: "reflection_usage",
			code: `
package main

import "reflect"

func trulyOrphanedFunc() {
	// This function might be called via reflection elsewhere
}

func main() {
	// Reflection usage in this file reduces confidence for orphaned functions
	_ = reflect.ValueOf(nil)
}
`,
			language: "go",
			file:     "reflection.go",
			expect:   "low_confidence",
		},
		{
			name: "generated_code",
			code: `
// Code generated by tool. DO NOT EDIT.
package main

func generatedFunc() {
	// Generated code
}
`,
			language: "go",
			file:     "generated.go",
			expect:   "low_confidence",
		},
		{
			name: "dynamic_import_js",
			code: `
export function unusedFunction() {
	// Might be imported dynamically
}

// Dynamic import
const module = await import('./other.js');
`,
			language: "javascript",
			file:     "dynamic.js",
			expect:   "low_confidence",
		},
		{
			name: "python_reflection",
			code: `
def unused_function():
	pass

# Reflection usage
func = getattr(module, 'unused_function')
func()
`,
			language: "python",
			file:     "reflection.py",
			expect:   "low_confidence",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			filePath := filepath.Join(tmpDir, tt.file)
			err := os.WriteFile(filePath, []byte(tt.code), 0644)
			if err != nil {
				t.Fatalf("Failed to create test file: %v", err)
			}

			findings, _, err := AnalyzeASTWithValidation(
				tt.code,
				tt.language,
				tt.file,
				projectRoot,
				[]string{"orphaned"},
			)

			if err != nil {
				t.Fatalf("Analysis failed: %v", err)
			}

			// Check that edge cases reduced confidence
			for _, finding := range findings {
				if finding.Type == "orphaned_code" {
					if tt.expect == "low_confidence" && finding.Confidence > 0.7 {
						t.Errorf("Expected low confidence (<=0.7) for edge case, got %.2f", finding.Confidence)
					}
					if finding.Validated {
						t.Logf("Finding validated: confidence=%.2f, reasoning=%s", finding.Confidence, finding.Reasoning)
					}
				}
			}
		})
	}
}

// TestMultiLanguageValidation tests validation across different languages
func TestMultiLanguageValidation(t *testing.T) {
	tmpDir := t.TempDir()
	projectRoot := tmpDir

	// Create JavaScript module
	jsFile := filepath.Join(tmpDir, "module.js")
	jsCode := `
export function helperFunction() {
	return "help";
}

export function unusedExport() {
	return "unused";
}
`
	err := os.WriteFile(jsFile, []byte(jsCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create JS file: %v", err)
	}

	// Create TypeScript file
	tsFile := filepath.Join(tmpDir, "types.ts")
	tsCode := `
export interface MyInterface {
	method(): void;
}

export class MyClass implements MyInterface {
	method(): void {
		// Implementation
	}
}
`
	err = os.WriteFile(tsFile, []byte(tsCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create TS file: %v", err)
	}

	// Create Python file
	pyFile := filepath.Join(tmpDir, "module.py")
	pyCode := `
def helper_function():
	return "help"

def _private_function():
	return "private"

class MyClass:
	def method(self):
		pass
`
	err = os.WriteFile(pyFile, []byte(pyCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create Python file: %v", err)
	}

	// Test JavaScript validation
	jsFindings, _, err := AnalyzeASTWithValidation(jsCode, "javascript", "module.js", projectRoot, []string{"orphaned"})
	if err != nil {
		t.Fatalf("JS validation failed: %v", err)
	}
	t.Logf("JavaScript findings: %d", len(jsFindings))

	// Test TypeScript validation
	tsFindings, _, err := AnalyzeASTWithValidation(tsCode, "typescript", "types.ts", projectRoot, []string{"orphaned"})
	if err != nil {
		t.Fatalf("TS validation failed: %v", err)
	}
	t.Logf("TypeScript findings: %d", len(tsFindings))

	// Test Python validation
	pyFindings, _, err := AnalyzeASTWithValidation(pyCode, "python", "module.py", projectRoot, []string{"orphaned"})
	if err != nil {
		t.Fatalf("Python validation failed: %v", err)
	}
	t.Logf("Python findings: %d", len(pyFindings))

	// Verify all findings were validated
	allFindings := append(append(jsFindings, tsFindings...), pyFindings...)
	for _, finding := range allFindings {
		if !finding.Validated {
			t.Errorf("Finding %s was not validated", finding.Type)
		}
	}
}
