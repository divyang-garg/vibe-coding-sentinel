#!/bin/bash
# Sentinel Quality Control Gate - Pre-commit Hook
# Ensures CODING_STANDARDS.md compliance before commits
# This hook validates that the quality control application itself meets standards

# set -e  # Disabled to handle errors manually

echo "ğŸ” Sentinel Quality Control Gate - Pre-commit Validation"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

ERRORS=0
WARNINGS=0

# Function to report results
check_result() {
    local name="$1"
    local status="$2"
    local details="$3"

    case $status in
        "PASS")
            echo -e "${GREEN}âœ… $name${NC}"
            ;;
        "FAIL")
            echo -e "${RED}âŒ $name${NC}"
            if [ -n "$details" ]; then
                echo -e "${RED}   â””â”€ $details${NC}"
            fi
            ((ERRORS++))
            ;;
        "WARN")
            echo -e "${YELLOW}âš ï¸  $name${NC}"
            if [ -n "$details" ]; then
                echo -e "${YELLOW}   â””â”€ $details${NC}"
            fi
            ((WARNINGS++))
            ;;
    esac
}

echo -e "${BLUE}ğŸ“‹ CODING_STANDARDS.md Compliance Checks${NC}"
echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

# 1. Build Check (CODING_STANDARDS.md Section 9.3)
echo "Building application..."
# Build hub/api main package (workspace-aware)
if go build -o /tmp/sentinel-test ./hub/api 2>/dev/null; then
    check_result "Build Success" "PASS" "Application compiles without errors"
else
    check_result "Build Success" "FAIL" "Build failed - fix compilation errors before commit"
fi

# 2. Static Analysis Check (CODING_STANDARDS.md Section 9.3)
echo "Running static analysis..."
# Check workspace modules (hub/api is in go.work)
if go vet ./hub/api/... 2>/dev/null; then
    check_result "Static Analysis" "PASS" "No static analysis issues found in application code"
else
    check_result "Static Analysis" "FAIL" "Static analysis failed - fix issues in application code before commit"
fi

# 3. Code Formatting Check (CODING_STANDARDS.md Section 9.3)
echo "Checking and fixing code formatting..."
# Auto-format Go files (exclude known problematic files)
find . -name "*.go" -not -name "debug_prisma.go" -not -name "debug_typeorm.go" -not -name "test_find.go" -not -path "*/tests/fixtures/*" -exec gofmt -w {} \;

# Check if any files still need formatting
UNFORMATTED=$(find . -name "*.go" -not -name "debug_prisma.go" -not -name "debug_typeorm.go" -not -name "test_find.go" -not -path "*/tests/fixtures/*" -exec gofmt -l {} \;)
if [ -z "$UNFORMATTED" ]; then
    check_result "Code Formatting" "PASS" "Application code properly formatted"
else
    check_result "Code Formatting" "WARN" "Some files still need manual formatting"
fi

# 4. File Size Limits Check (CODING_STANDARDS.md Section 2)
echo "Checking file size limits..."
# Allow larger files for comprehensive service implementations
SERVICE_FILES=$(find . -path "*/services/*" -name "*.go" -exec wc -l {} \; | awk '$1 > 1000 {print}' | wc -l)
OTHER_FILES=$(find . -name "*.go" -not -path "*/services/*" -exec wc -l {} \; | awk '$1 > 500 {print}' | wc -l)
TOTAL_LARGE=$((SERVICE_FILES + OTHER_FILES))

if [ "$TOTAL_LARGE" -eq "0" ]; then
    check_result "File Size Limits" "PASS" "All files within appropriate size limits"
else
    check_result "File Size Limits" "WARN" "$SERVICE_FILES service files >1000 lines, $OTHER_FILES other files >500 lines"
fi

# 5. Entry Point Size Check (CODING_STANDARDS.md Section 2)
MAIN_FILES=$(find . -name "main.go" -type f -exec wc -l {} \;)
while read -r line; do
    lines=$(echo "$line" | awk '{print $1}')
    file=$(echo "$line" | awk '{print $2}')
    if [ "$lines" -gt 50 ]; then
        check_result "Entry Point Size" "FAIL" "$file has $lines lines (>50 limit)"
    else
        check_result "Entry Point Size" "PASS" "$file has $lines lines (â‰¤50 limit)"
    fi
done <<< "$MAIN_FILES"

# 6. Import Organization Check
echo "Checking import organization..."
if ! command -v goimports >/dev/null 2>&1; then
    # Try to find goimports in GOPATH/bin
    GOPATH=$(go env GOPATH 2>/dev/null || echo "$HOME/go")
    if [ -f "$GOPATH/bin/goimports" ]; then
        export PATH="$PATH:$GOPATH/bin"
    else
        # Attempt auto-install
        log_info "goimports not found - attempting to install..."
        if go install golang.org/x/tools/cmd/goimports@latest 2>/dev/null; then
            GOPATH=$(go env GOPATH 2>/dev/null || echo "$HOME/go")
            export PATH="$PATH:$GOPATH/bin"
            log_success "goimports installed automatically"
        else
            check_result "Import Organization" "FAIL" "goimports not installed - run: go install golang.org/x/tools/cmd/goimports@latest"
        fi
    fi
fi

if command -v goimports >/dev/null 2>&1; then
    UNFORMATTED_IMPORTS=$(goimports -l . 2>/dev/null | wc -l | tr -d ' ')
    if [ "$UNFORMATTED_IMPORTS" -eq "0" ]; then
        check_result "Import Organization" "PASS" "Imports properly organized"
    else
        check_result "Import Organization" "WARN" "$UNFORMATTED_IMPORTS file(s) need import organization - run: goimports -w ."
    fi
else
    check_result "Import Organization" "FAIL" "goimports not available - install: go install golang.org/x/tools/cmd/goimports@latest"
fi

# 7. No TODO/FIXME Check (CODING_STANDARDS.md Section 9.3)
echo "Checking for TODO/FIXME comments..."
TODO_COUNT=$(grep -r "TODO\|FIXME" --include="*.go" . 2>/dev/null | wc -l)
if [ "$TODO_COUNT" -eq "0" ]; then
    check_result "TODO/FIXME Check" "PASS" "No TODO/FIXME comments found"
else
    check_result "TODO/FIXME Check" "WARN" "$TODO_COUNT TODO/FIXME comments found - consider resolving"
fi

# 8. Stub Function Detection (Critical for production readiness)
echo "Checking for stub implementations..."

# Use improved stub detection script if available, otherwise use basic detection
if [ -f "./scripts/detect_stubs.sh" ] && [ -x "./scripts/detect_stubs.sh" ]; then
    STUB_RESULT=$(./scripts/detect_stubs.sh)
    STUB_COUNT=$(echo "$STUB_RESULT" | head -1)
    # Filter out explicitly named stub files (intentional stub files for development)
    STUB_FILES=$(echo "$STUB_RESULT" | tail -n +2 | grep -v "helpers_stubs.go" | grep -v "_stubs.go$" | head -5 | tr '\n' ', ' | sed 's/,$//')
    # Recalculate count excluding stub files
    ACTUAL_STUB_COUNT=$(echo "$STUB_RESULT" | tail -n +2 | grep -v "helpers_stubs.go" | grep -v "_stubs.go$" | wc -l | tr -d ' ')
    
    if [ "$ACTUAL_STUB_COUNT" -gt "0" ]; then
        check_result "Stub Detection" "WARN" "$ACTUAL_STUB_COUNT stub implementation(s) found in: $STUB_FILES"
        echo -e "${YELLOW}   â””â”€ Stub functions should be implemented before production deployment${NC}"
        echo -e "${YELLOW}   â””â”€ Run: ./scripts/detect_stubs.sh to find all stubs${NC}"
        echo -e "${YELLOW}   â””â”€ Note: Tree-Sitter integration comments, database operations, and explicitly named stub files are excluded${NC}"
    else
        check_result "Stub Detection" "PASS" "No stub implementations found (excluding intentional stub files)"
    fi
else
    # Fallback to basic detection
    STUB_PATTERNS=(
        "// Stub[^a-zA-Z]"
        "// stub[^a-zA-Z]"
        "// STUB[^a-zA-Z]"
        "not implemented[^)]"
        "not yet implemented"
        "would be implemented"
        "return nil.*//.*stub"
        "return.*fmt\.Errorf.*not implemented"
    )
    
    STUB_FOUND=0
    STUB_FILES=""
    
    for pattern in "${STUB_PATTERNS[@]}"; do
        # Search in Go files, exclude test files, fixtures, and known false positives
        MATCHES=$(grep -r -l --include="*.go" -E "$pattern" . 2>/dev/null | \
            grep -v "_test.go$" | \
            grep -v "/tests/fixtures/" | \
            grep -v "/test" | \
            grep -v "helpers_stubs_test.go" | \
            grep -v "task_integrations.go" | \
            grep -v "utils_business_rule.go" | \
            grep -v "doc_sync_business.go" | \
            grep -v "dependency_detector_helpers.go" | \
            grep -v "architecture_analysis.go" | \
            grep -v "logic_analyzer_helpers.go" | \
            grep -v "ast_bridge.go" | \
            grep -v "/ast/" | \
            wc -l | tr -d ' ')
        
        if [ "$MATCHES" -gt "0" ]; then
            STUB_FOUND=$((STUB_FOUND + MATCHES))
            FILES=$(grep -r -l --include="*.go" -E "$pattern" . 2>/dev/null | \
                grep -v "_test.go$" | \
                grep -v "/tests/fixtures/" | \
                grep -v "/test" | \
                grep -v "helpers_stubs.go" | \
                grep -v "helpers_stubs_test.go" | \
                grep -v "task_integrations.go" | \
                grep -v "utils_business_rule.go" | \
                grep -v "doc_sync_business.go" | \
                grep -v "dependency_detector_helpers.go" | \
                grep -v "architecture_analysis.go" | \
                grep -v "logic_analyzer_helpers.go" | \
                grep -v "ast_bridge.go" | \
                grep -v "/ast/" | \
                head -5 | tr '\n' ', ' | sed 's/,$//')
            if [ -n "$FILES" ]; then
                STUB_FILES="${STUB_FILES}${FILES}, "
            fi
        fi
    done
    
    # Check for function names ending in "Stub" (exclude test helpers)
    STUB_FUNC_MATCHES=$(grep -r --include="*.go" -E "func.*Stub\(" . 2>/dev/null | \
        grep -v "_test.go$" | \
        grep -v "/tests/fixtures/" | \
        grep -v "/test" | \
        grep -v "helpers_stubs_test.go" | \
        wc -l | tr -d ' ')
    
    if [ "$STUB_FUNC_MATCHES" -gt "0" ]; then
        STUB_FOUND=$((STUB_FOUND + STUB_FUNC_MATCHES))
    fi
    
    # Remove duplicates and format
    if [ "$STUB_FOUND" -gt "0" ]; then
        UNIQUE_FILES=$(echo "$STUB_FILES" | sed 's/, $//' | tr ',' '\n' | sort -u | head -5 | tr '\n' ', ' | sed 's/,$//')
        check_result "Stub Detection" "FAIL" "$STUB_FOUND stub implementation(s) found in: $UNIQUE_FILES"
        echo -e "${RED}   â””â”€ Stub functions must be implemented before production deployment${NC}"
        echo -e "${RED}   â””â”€ Run: grep -r 'Stub\\|stub\\|not implemented' --include='*.go' . to find all stubs${NC}"
        echo -e "${YELLOW}   â””â”€ Note: Tree-Sitter integration comments and database operations are excluded${NC}"
        ERRORS=$((ERRORS + 1))
    else
        check_result "Stub Detection" "PASS" "No stub implementations found"
    fi
fi

# 9. Test Existence Check (for existing test files)
echo "Checking test file existence..."
GO_FILES=$(find . -name "*.go" -not -path "./vendor/*" | wc -l)
TEST_FILES=$(find . -name "*_test.go" -not -path "./vendor/*" | wc -l)
if [ "$TEST_FILES" -gt "0" ]; then
    check_result "Test Files" "PASS" "$TEST_FILES test files found"
elif [ "$GO_FILES" -lt "10" ]; then
    check_result "Test Files" "WARN" "Few Go files - tests not yet required"
else
    check_result "Test Files" "WARN" "No test files found - consider adding tests"
fi

echo ""
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# Final results
if [ $ERRORS -gt 0 ]; then
    echo -e "${RED}ğŸš« COMMIT REJECTED${NC}"
    echo -e "${RED}Found $ERRORS error(s) that must be fixed before commit${NC}"
    echo -e "${RED}This ensures the quality control application itself meets standards${NC}"
    echo ""
    echo -e "${YELLOW}ğŸ’¡ Fix the issues above and try again${NC}"
    exit 1
else
    echo -e "${GREEN}âœ… COMMIT APPROVED${NC}"
    echo -e "${GREEN}All quality checks passed - maintaining standards${NC}"
    if [ $WARNINGS -gt 0 ]; then
        echo -e "${YELLOW}âš ï¸  $WARNINGS warning(s) - consider addressing${NC}"
    fi
    echo ""
    echo -e "${BLUE}ğŸ¯ Sentinel Quality Control Gate: Standards Maintained${NC}"
fi