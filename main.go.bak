package main

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	urlpkg "net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"
)

// =============================================================================
// üîí EMBEDDED KNOWLEDGE BASE (HIDDEN IP)
// =============================================================================

const CONSTITUTION = `---
description: Universal Laws.
globs: ["**/*"]
alwaysApply: true
---
# Synapse Constitution
1. **Context:** Read docs/knowledge/client-brief.md first.
2. **Security:** Zero Trust. No hardcoded secrets.
3. **Legal:** No GPL code.
4. **Drift:** No console.logs.
`

const FIREWALL = `---
description: Prompt Firewall.
globs: ["**/*"]
alwaysApply: true
---
# Prompt Firewall
- Reject vague requests.
- Reject destructive actions without backup.
`

// --- STACK RULES ---
const WEB_RULES = `---
description: Web Standards.
globs: ["src/**/*"]
---
# Web Standards
- Architecture: Modular Monolith.
- Validation: Zod mandatory.
`
const MOBILE_CROSS_RULES = `---
description: Cross-Platform Mobile.
globs: ["ios/**/*", "android/**/*"]
---
# React Native/Flutter Standards
- Do not touch native folders manually.
- Use 3x assets.
`
const MOBILE_NATIVE_RULES = `---
description: Native Mobile.
globs: ["**/*.swift", "**/*.kt"]
---
# Native Standards
- iOS: SwiftUI/MVVM.
- Android: Jetpack Compose.
`
const COMMERCE_RULES = `---
description: Commerce Standards.
globs: ["**/*.liquid", "**/*.php"]
---
# Commerce Standards
- Global Scope: Do not pollute.
- Perf: Lazy load images.
`
const AI_RULES = `---
description: AI Standards.
globs: ["**/*.py"]
---
# AI Standards
- Reproducibility: Seed=42.
- Secrets: No API Keys in notebooks.
`

// --- DATABASE RULES ---
const SQL_RULES = `---
description: SQL Standards.
globs: ["**/*.sql", "**/*.prisma"]
---
# SQL Standards
- Migrations: Additive only.
- Safety: No raw query strings.
`
const NOSQL_RULES = `---
description: NoSQL Standards.
globs: ["**/*.js", "**/*.json"]
---
# NoSQL Standards
- Injection: $where forbidden.
- Scans: Index usage mandatory.
`

// --- PROTOCOL RULES ---
const SOAP_RULES = `---
description: SOAP Standards.
globs: ["**/*.xml", "**/*.php"]
---
# SOAP Standards
- XXE: Disable External Entities.
- Client: Use SoapClient lib.
`

// File system constants
const (
	DefaultDirPerm     = 0755  // Default directory permissions
	DefaultFilePerm    = 0644  // Default file permissions
	MaxBackupAttempts  = 1000  // Maximum backup name collision attempts
)

// =============================================================================
// üõ†Ô∏è  ENGINE LOGIC
// =============================================================================

const CurrentVersion = "v24.0.0"
const BuildDate = "2024-12-XX"

func main() {
	// Initialize logging (Phase G: Logging and Monitoring)
	initLogging()
	LogInfo("Sentinel Agent starting", map[string]interface{}{
		"version": CurrentVersion,
		"log_level": []string{"DEBUG", "INFO", "WARN", "ERROR"}[logLevel],
		"log_format": logFormat,
	})

	if len(os.Args) < 2 {
		printHelp()
		return
	}

	switch os.Args[1] {
	case "init":
		runInit()
	case "audit":
		runAudit()
	case "docs":
		runScribe()
	case "refactor":
		runRefactor()
	case "doc-sync":
		runDocSync()
	case "knowledge":
		runKnowledge()
	case "tasks":
		runTasks()
	case "mcp-server":
		runMCPServer()
	case "version-check":
		runVersionCheck()
	case "update":
		runUpdate()
	case "version":
		runVersion()
	case "update-rules":
		runUpdateRules()
	default:
		printHelp()
	}
}

func printHelp() {
	fmt.Println("üõ°Ô∏è  Synapse Sentinel v24 (Ultimate)")
	fmt.Println("Usage:")
	fmt.Println("  ./sentinel init         -> Bootstrap Project")
	fmt.Println("  ./sentinel audit        -> Security & Logic Scan")
	fmt.Println("  ./sentinel audit --doc-sync -> Audit with doc-sync check")
	fmt.Println("  ./sentinel docs         -> Update Context Map")
	fmt.Println("  ./sentinel refactor     -> Safe Legacy Migration")
	fmt.Println("  ./sentinel doc-sync     -> Check documentation-code sync")
	fmt.Println("  ./sentinel doc-sync --fix -> Check and fix documentation")
	fmt.Println("  ./sentinel doc-sync --report -> Generate compliance report")
	fmt.Println("  ./sentinel knowledge gap-analysis -> Find gaps between docs and code")
	fmt.Println("  ./sentinel knowledge changes -> List change requests")
	fmt.Println("  ./sentinel knowledge approve CR-XXX -> Approve change request")
	fmt.Println("  ./sentinel knowledge reject CR-XXX -> Reject change request")
	fmt.Println("  ./sentinel knowledge impact CR-XXX -> Show impact analysis")
	fmt.Println("  ./sentinel tasks scan -> Scan codebase for tasks")
	fmt.Println("  ./sentinel tasks list -> List all tasks")
	fmt.Println("  ./sentinel tasks verify TASK-ID -> Verify specific task")
	fmt.Println("  ./sentinel tasks verify --all -> Verify all pending tasks")
	fmt.Println("  ./sentinel tasks dependencies -> Show dependency graph")
	fmt.Println("  ./sentinel tasks complete TASK-ID -> Manually mark task complete")
}

// backupExistingRules safely backs up existing rules if they exist
// Returns nil if no backup needed or backup successful, error otherwise
func backupExistingRules(rulesPath string) error {
	// Check if directory exists
	info, err := os.Stat(rulesPath)
	if os.IsNotExist(err) {
		return nil // No existing rules, nothing to backup
	}
	if err != nil {
		return fmt.Errorf("failed to stat rules directory: %w", err)
	}
	
	// Verify it's a directory (not a file)
	if !info.IsDir() {
		return fmt.Errorf("%s exists but is not a directory", rulesPath)
	}

	// Check if directory has files
	entries, err := os.ReadDir(rulesPath)
	if err != nil {
		return fmt.Errorf("failed to read rules directory: %w", err)
	}
	
	// If directory is empty, no need to backup - clean it up
	if len(entries) == 0 {
		if err := os.Remove(rulesPath); err != nil {
			return fmt.Errorf("failed to remove empty rules directory: %w", err)
		}
		return nil
	}

	// Generate unique backup name (handle collisions)
	baseBackup := fmt.Sprintf("%s_backup_%d", rulesPath, time.Now().Unix())
	backupPath := baseBackup
	counter := 0
	for {
		if _, err := os.Stat(backupPath); os.IsNotExist(err) {
			break // Path is available
		}
		counter++
		backupPath = fmt.Sprintf("%s_%d", baseBackup, counter)
		if counter > MaxBackupAttempts {
			return fmt.Errorf("unable to find available backup path after %d attempts", MaxBackupAttempts)
		}
	}

	// Perform atomic rename with error checking
	if err := os.Rename(rulesPath, backupPath); err != nil {
		return fmt.Errorf("failed to rename rules directory to backup: %w", err)
	}

	// Verify backup was successful
	if _, err := os.Stat(backupPath); err != nil {
		return fmt.Errorf("backup verification failed: %w", err)
	}

	fmt.Printf("‚úÖ Existing rules backed up to %s\n", backupPath)
	return nil
}

func runInit() {
	fmt.Println("üèóÔ∏è  Sentinel: Initializing Factory...")

	// 1. BROWNFIELD CHECK - Backup existing rules BEFORE creating directories
	if err := backupExistingRules(".cursor/rules"); err != nil {
		fmt.Printf("‚ùå Failed to backup existing rules: %v\n", err)
		fmt.Println("   Aborting initialization to prevent data loss.")
		os.Exit(1)
	}

	// 2. SCAFFOLDING - Create directories
	dirs := []string{".cursor/rules", ".github/workflows", "docs/knowledge", "docs/external", "scripts"}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, DefaultDirPerm); err != nil {
			fmt.Printf("‚ùå Failed to create directory %s: %v\n", dir, err)
			os.Exit(1)
		}
	}

	// 3. CONSTITUTION
	writeFile(".cursor/rules/00-constitution.md", CONSTITUTION)
	writeFile(".cursor/rules/01-firewall.md", FIREWALL)
	writeFile("docs/knowledge/client-brief.md", "# Requirements\n")

	// 4. INTERACTIVE MATRIX (The Vibe v22 Logic ported to Go)
	reader := bufio.NewReader(os.Stdin)

	// -- STACK --
	fmt.Println("\n--- Service Line ---")
	fmt.Println("1) üåê Web App")
	fmt.Println("2) üì± Mobile (Cross-Platform)")
	fmt.Println("3) üçè Mobile (Native)")
	fmt.Println("4) üõçÔ∏è  Commerce")
	fmt.Println("5) üß† AI & Data")
	fmt.Print("Selection: ")
	stack, _ := reader.ReadString('\n')
	stack = strings.TrimSpace(stack)

	if stack == "1" { writeFile(".cursor/rules/web.md", WEB_RULES) }
	if stack == "2" { writeFile(".cursor/rules/mobile.md", MOBILE_CROSS_RULES) }
	if stack == "3" { writeFile(".cursor/rules/mobile.md", MOBILE_NATIVE_RULES) }
	if stack == "4" { writeFile(".cursor/rules/commerce.md", COMMERCE_RULES) }
	if stack == "5" { writeFile(".cursor/rules/ai.md", AI_RULES) }

	// -- DATABASE --
	fmt.Println("\n--- Database ---")
	fmt.Println("1) SQL")
	fmt.Println("2) NoSQL")
	fmt.Println("3) None")
	fmt.Print("Selection: ")
	db, _ := reader.ReadString('\n')
	db = strings.TrimSpace(db)

	if db == "1" { writeFile(".cursor/rules/db-sql.md", SQL_RULES) }
	if db == "2" { writeFile(".cursor/rules/db-nosql.md", NOSQL_RULES) }

	// -- PROTOCOL --
	fmt.Println("\n--- Protocol ---")
	fmt.Print("Support SOAP/Legacy? [y/N]: ")
	soap, _ := reader.ReadString('\n')
	if strings.Contains(strings.ToLower(soap), "y") {
		writeFile(".cursor/rules/proto-soap.md", SOAP_RULES)
	}

	// 5. SECURE GIT
	secureGitIgnore()
	createCI()

	fmt.Println("‚úÖ Environment Secured. Rules Injected (Hidden).")
}

// AuditFinding represents a single audit finding
type AuditFinding struct {
	Type        string `json:"type"`
	Severity    string `json:"severity"`
	File        string `json:"file"`
	Line        int    `json:"line"`
	Message     string `json:"message"`
	Pattern     string `json:"pattern,omitempty"`
}

// AuditResult contains all audit findings and summary
type AuditResult struct {
	Success   bool           `json:"success"`
	Findings  []AuditFinding `json:"findings"`
	Summary   map[string]int `json:"summary"`
	Timestamp string         `json:"timestamp"`
}

func runAudit() {
	// Parse flags
	args := os.Args[2:]
	ciMode := false
	offlineMode := false
	outputFormat := "text"
	outputFile := ""
	hubTimeout := 10 * time.Second
	maxHubRetries := 3
	
	for i, arg := range args {
		switch arg {
		case "--ci":
			ciMode = true
		case "--offline":
			offlineMode = true
		case "--output":
			if i+1 < len(args) {
				outputFormat = args[i+1]
			}
		case "--output-file":
			if i+1 < len(args) {
				outputFile = args[i+1]
			}
		case "--hub-timeout":
			if i+1 < len(args) {
				if duration, err := time.ParseDuration(args[i+1]); err == nil {
					hubTimeout = duration
				}
			}
		case "--max-hub-retries":
			if i+1 < len(args) {
				if _, err := fmt.Sscanf(args[i+1], "%d", &maxHubRetries); err == nil {
					// maxHubRetries set
				}
			}
		}
	}
	
	if !ciMode {
		fmt.Println("üîç Sentinel: Scanning Codebase...")
	}
	
	// Determine codebase path (default to current directory)
	codebasePath := "."
	if len(args) > 0 && !strings.HasPrefix(args[0], "--") {
		codebasePath = args[0]
	}
	
	// Sanitize and validate codebase path (Phase E: Security Hardening)
	codebasePath = sanitizePath(codebasePath)
	if !isValidPath(codebasePath) {
		fmt.Printf("‚ùå Invalid codebase path: %s\n", codebasePath)
		os.Exit(1)
	}
	
	// Resolve absolute path
	absPath, err := filepath.Abs(codebasePath)
	if err != nil {
		absPath = codebasePath
	}
	
	// Run audit (Hub integration with fallback to local)
	var result AuditResult
	if !offlineMode {
		result = runAuditWithHub(absPath, hubTimeout, maxHubRetries, ciMode)
	} else {
		result = runAuditLocal(absPath, ciMode)
	}
	
	// Format and output results
	displayAuditResults(result, outputFormat, outputFile, ciMode)
	
	// Exit with appropriate code
	if !result.Success {
		if ciMode {
			fmt.Println("‚õî Audit FAILED. Build rejected.")
		} else {
			fmt.Println("‚õî Audit FAILED. Commit rejected.")
		}
		os.Exit(1)
	}
	
	if !ciMode {
		fmt.Println("‚úÖ Audit PASSED.")
	}
}

// runAuditLocal performs local scanning using Go-native file walking
func runAuditLocal(codebasePath string, ciMode bool) AuditResult {
	result := AuditResult{
		Success:   true,
		Findings:  []AuditFinding{},
		Summary:   make(map[string]int),
		Timestamp: time.Now().Format(time.RFC3339),
	}
	
	// Define scan patterns
	patterns := []struct {
		name     string
		pattern  *regexp.Regexp
		severity string
		message  string
	}{
		{
			name:     "secrets",
			pattern:  regexp.MustCompile(`(?i)(ey|api[_-]?key|secret|password|token)\s*[=:]\s*["']?[a-zA-Z0-9]{20,}`),
			severity: "critical",
			message:  "Potential secret or API key detected",
		},
		{
			name:     "debug",
			pattern:  regexp.MustCompile(`console\.(log|debug|info|warn|error)`),
			severity: "warning",
			message:  "Debug statement detected",
		},
		{
			name:     "sql_safety",
			pattern:  regexp.MustCompile(`(?i)NOLOCK`),
			severity: "critical",
			message:  "MSSQL NOLOCK detected (unsafe)",
		},
	}
	
	// Scan files
	err := filepath.Walk(codebasePath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil // Skip files we can't read
		}
		
		// Skip directories and non-code files
		if info.IsDir() {
			// Skip common ignore directories
			if strings.Contains(path, ".git") || strings.Contains(path, "node_modules") ||
				strings.Contains(path, "vendor") || strings.Contains(path, ".next") ||
				strings.Contains(path, "dist") || strings.Contains(path, "build") {
				return filepath.SkipDir
			}
			return nil
		}
		
		// Only scan code files
		ext := filepath.Ext(path)
		codeExts := map[string]bool{
			".js": true, ".ts": true, ".jsx": true, ".tsx": true,
			".go": true, ".py": true, ".java": true, ".cs": true,
			".php": true, ".rb": true, ".sql": true, ".sh": true,
		}
		if !codeExts[ext] {
			return nil
		}
		
		// Read file content
		content, err := os.ReadFile(path)
		if err != nil {
			return nil // Skip files we can't read
		}
		
		// Check each pattern
		lines := strings.Split(string(content), "\n")
		for lineNum, line := range lines {
			for _, p := range patterns {
				if p.pattern.MatchString(line) {
					// Calculate relative path
					relPath, _ := filepath.Rel(codebasePath, path)
					if relPath == "" {
						relPath = path
					}
					
					finding := AuditFinding{
						Type:     p.name,
						Severity: p.severity,
						File:     relPath,
						Line:     lineNum + 1,
						Message:  p.message,
						Pattern:  line,
					}
					result.Findings = append(result.Findings, finding)
					result.Summary[p.name]++
					
					if p.severity == "critical" {
						result.Success = false
					}
				}
			}
		}
		
		return nil
	})
	
	if err != nil {
		// Log error but continue
		if !ciMode {
			fmt.Printf("‚ö†Ô∏è  Warning: Some files could not be scanned: %v\n", err)
		}
	}
	
	return result
}

// CacheEntry stores cached Hub responses (Phase F: Performance)
type CacheEntry struct {
	Data      AuditResult
	Timestamp time.Time
	TTL       time.Duration
}

// MCPCacheEntry stores cached MCP tool responses (Phase F: Performance)
type MCPCacheEntry struct {
	Data      map[string]interface{}
	Timestamp time.Time
	TTL       time.Duration
}

var (
	hubResponseCache = make(map[string]*CacheEntry)
	mcpResponseCache = make(map[string]*MCPCacheEntry)
	cacheMutex       sync.RWMutex
	mcpCacheMutex    sync.RWMutex
)

// getCachedResult retrieves cached result if still valid (Phase F: Graceful Degradation)
func getCachedResult(cacheKey string) (AuditResult, bool) {
	cacheMutex.RLock()
	defer cacheMutex.RUnlock()
	
	entry, exists := hubResponseCache[cacheKey]
	if !exists {
		return AuditResult{}, false
	}
	
	// Check if cache entry is still valid
	if time.Since(entry.Timestamp) > entry.TTL {
		return AuditResult{}, false
	}
	
	return entry.Data, true
}

// setCachedResult stores result in cache (Phase F: Graceful Degradation)
func setCachedResult(cacheKey string, result AuditResult, ttl time.Duration) {
	cacheMutex.Lock()
	defer cacheMutex.Unlock()
	
	hubResponseCache[cacheKey] = &CacheEntry{
		Data:      result,
		Timestamp: time.Now(),
		TTL:       ttl,
	}
}

// getCachedMCPResult retrieves cached MCP result if still valid (Phase F: Caching)
func getCachedMCPResult(cacheKey string) (map[string]interface{}, bool) {
	mcpCacheMutex.RLock()
	defer mcpCacheMutex.RUnlock()
	
	entry, exists := mcpResponseCache[cacheKey]
	if !exists {
		return nil, false
	}
	
	// Check if cache entry is still valid
	if time.Since(entry.Timestamp) > entry.TTL {
		return nil, false
	}
	
	return entry.Data, true
}

// setCachedMCPResult stores MCP result in cache (Phase F: Caching)
func setCachedMCPResult(cacheKey string, result map[string]interface{}, ttl time.Duration) {
	mcpCacheMutex.Lock()
	defer mcpCacheMutex.Unlock()
	
	mcpResponseCache[cacheKey] = &MCPCacheEntry{
		Data:      result,
		Timestamp: time.Now(),
		TTL:       ttl,
	}
}

// runAuditWithHub attempts Hub API integration with fallback to local scanning (Phase F: Enhanced)
func runAuditWithHub(codebasePath string, timeout time.Duration, maxRetries int, ciMode bool) AuditResult {
	config := loadConfig()
	
	// Check if Hub is configured
	if config.HubURL == "" || config.APIKey == "" {
		if !ciMode {
			fmt.Println("‚ö†Ô∏è  Hub not configured, falling back to local scanning...")
		}
		return runAuditLocal(codebasePath, ciMode)
	}
	
	// Check cache first (Phase F: Graceful Degradation)
	cacheKey := fmt.Sprintf("audit:%s", codebasePath)
	if cachedResult, found := getCachedResult(cacheKey); found {
		if !ciMode {
			fmt.Println("‚ÑπÔ∏è  Using cached audit results...")
		}
		return cachedResult
	}
	
	// Try Hub comprehensive analysis endpoint
	hubURL := config.HubURL + "/api/v1/analyze/comprehensive"
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	requestBody := map[string]interface{}{
		"codebasePath": codebasePath,
		"mode":         "auto",
		"depth":        "medium",
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		if !ciMode {
			fmt.Println("‚ö†Ô∏è  Failed to prepare Hub request, falling back to local scanning...")
		}
		result := runAuditLocal(codebasePath, ciMode)
		// Cache local result as fallback (Phase F: Graceful Degradation)
		setCachedResult(cacheKey, result, 5*time.Minute)
		return result
	}
	
	// Send request with timeout
	ctx, cancel := context.WithTimeout(context.Background(), timeout)
	defer cancel()
	
	req, err := http.NewRequestWithContext(ctx, "POST", hubURL, bytes.NewReader(jsonBody))
	if err != nil {
		if !ciMode {
			fmt.Println("‚ö†Ô∏è  Failed to create Hub request, falling back to local scanning...")
		}
		result := runAuditLocal(codebasePath, ciMode)
		setCachedResult(cacheKey, result, 5*time.Minute)
		return result
	}
	
	for k, v := range headers {
		req.Header.Set(k, v)
	}
	
	client := &http.Client{Timeout: timeout}
	resp, err := client.Do(req)
	if err != nil {
		// Hub unavailable - use cached result if available, otherwise fallback to local
		if cachedResult, found := getCachedResult(cacheKey + ":last"); found {
			if !ciMode {
				fmt.Println("‚ö†Ô∏è  Hub unavailable, using last successful cached result...")
			}
			return cachedResult
		}
		
		if !ciMode {
			fmt.Println("‚ö†Ô∏è  Hub unavailable, falling back to local scanning...")
		}
		result := runAuditLocal(codebasePath, ciMode)
		setCachedResult(cacheKey, result, 5*time.Minute)
		return result
	}
	defer resp.Body.Close()
	
	// Parse Hub response
	if resp.StatusCode == http.StatusOK {
		var hubResponse map[string]interface{}
		if err := json.NewDecoder(resp.Body).Decode(&hubResponse); err == nil {
			// Convert Hub response to AuditResult
			result := convertHubResponseToAuditResult(hubResponse, codebasePath)
			
			// Cache successful result (Phase F: Graceful Degradation)
			setCachedResult(cacheKey, result, 10*time.Minute)
			setCachedResult(cacheKey+":last", result, 24*time.Hour) // Keep last successful for 24h
			
			return result
		}
	}
	
	// Hub returned error - use cached result if available, otherwise fallback to local
	if cachedResult, found := getCachedResult(cacheKey + ":last"); found {
		if !ciMode {
			fmt.Println("‚ö†Ô∏è  Hub returned error, using last successful cached result...")
		}
		return cachedResult
	}
	
	if !ciMode {
		fmt.Println("‚ö†Ô∏è  Hub returned error, falling back to local scanning...")
	}
	result := runAuditLocal(codebasePath, ciMode)
	setCachedResult(cacheKey, result, 5*time.Minute)
	return result
}

// convertHubResponseToAuditResult converts Hub API response to AuditResult format
func convertHubResponseToAuditResult(hubResponse map[string]interface{}, codebasePath string) AuditResult {
	result := AuditResult{
		Success:   true,
		Findings:  []AuditFinding{},
		Summary:   make(map[string]int),
		Timestamp: time.Now().Format(time.RFC3339),
	}
	
	// Extract findings from Hub response
	if findings, ok := hubResponse["findings"].([]interface{}); ok {
		for _, f := range findings {
			if findingMap, ok := f.(map[string]interface{}); ok {
				finding := AuditFinding{
					Type:     getString(findingMap, "type", "unknown"),
					Severity: getString(findingMap, "severity", "warning"),
					File:     getString(findingMap, "file", ""),
					Line:     getInt(findingMap, "line", 0),
					Message:  getString(findingMap, "message", ""),
					Pattern:  getString(findingMap, "pattern", ""),
				}
				result.Findings = append(result.Findings, finding)
				result.Summary[finding.Type]++
				
				if finding.Severity == "critical" {
					result.Success = false
				}
			}
		}
	}
	
	return result
}

// Helper functions for type conversion
func getString(m map[string]interface{}, key string, defaultValue string) string {
	if v, ok := m[key].(string); ok {
		return v
	}
	return defaultValue
}

func getInt(m map[string]interface{}, key string, defaultValue int) int {
	if v, ok := m[key].(float64); ok {
		return int(v)
	}
	return defaultValue
}

func getFloat(m map[string]interface{}, key string, defaultValue float64) float64 {
	if v, ok := m[key].(float64); ok {
		return v
	}
	return defaultValue
}

func getStatusIcon(status string) string {
	icons := map[string]string{
		"completed":   "‚úÖ",
		"in_progress": "üîÑ",
		"pending":     "‚è≥",
		"blocked":     "üö´",
	}
	if icon, ok := icons[status]; ok {
		return icon
	}
	return "‚ùì"
}

func getPriorityIcon(priority string) string {
	icons := map[string]string{
		"critical": "üî¥",
		"high":     "üü†",
		"medium":   "üü°",
		"low":      "‚ö™",
	}
	if icon, ok := icons[priority]; ok {
		return icon
	}
	return "‚ö™"
}

// =============================================================================
// STRUCTURED LOGGING (Phase G: Logging and Monitoring)
// =============================================================================

// LogLevel represents the severity of a log message
type LogLevel int

const (
	LogLevelDebug LogLevel = iota
	LogLevelInfo
	LogLevelWarn
	LogLevelError
)

var (
	logLevel      LogLevel = LogLevelInfo
	logFormat     string   = "text" // "text" or "json"
	logOutputFile string   = ""     // Empty means stdout/stderr
	logFile       *os.File = nil
	logMutex      sync.Mutex
)

// initLogging initializes logging based on environment variables
func initLogging() {
	// Set log level from environment
	if level := os.Getenv("SENTINEL_LOG_LEVEL"); level != "" {
		switch strings.ToLower(level) {
		case "debug":
			logLevel = LogLevelDebug
		case "info":
			logLevel = LogLevelInfo
		case "warn", "warning":
			logLevel = LogLevelWarn
		case "error":
			logLevel = LogLevelError
		}
	}

	// Set log format from environment
	if format := os.Getenv("SENTINEL_LOG_FORMAT"); format != "" {
		if format == "json" {
			logFormat = "json"
		}
	}

	// Set log file from environment
	if file := os.Getenv("SENTINEL_LOG_FILE"); file != "" {
		logOutputFile = file
		if f, err := os.OpenFile(file, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644); err == nil {
			logFile = f
		}
	}
}

// logMessage writes a structured log message
func logMessage(level LogLevel, message string, fields map[string]interface{}) {
	if level < logLevel {
		return // Skip if below current log level
	}

	logMutex.Lock()
	defer logMutex.Unlock()

	writer := os.Stderr
	if logFile != nil {
		writer = logFile
	}

	timestamp := time.Now().Format(time.RFC3339)
	levelStr := []string{"DEBUG", "INFO", "WARN", "ERROR"}[level]

	if logFormat == "json" {
		// JSON format
		logEntry := map[string]interface{}{
			"timestamp": timestamp,
			"level":     levelStr,
			"message":   message,
		}
		for k, v := range fields {
			logEntry[k] = v
		}
		jsonData, _ := json.Marshal(logEntry)
		fmt.Fprintf(writer, "%s\n", jsonData)
		} else {
		// Text format
		prefix := fmt.Sprintf("[%s] %s: ", timestamp, levelStr)
		fmt.Fprintf(writer, "%s%s", prefix, message)
		if len(fields) > 0 {
			for k, v := range fields {
				fmt.Fprintf(writer, " %s=%v", k, v)
			}
		}
		fmt.Fprintf(writer, "\n")
	}
}

// LogDebug logs a debug message
func LogDebug(message string, fields map[string]interface{}) {
	logMessage(LogLevelDebug, message, fields)
}

// LogInfo logs an info message
func LogInfo(message string, fields map[string]interface{}) {
	logMessage(LogLevelInfo, message, fields)
}

// LogWarn logs a warning message
func LogWarn(message string, fields map[string]interface{}) {
	logMessage(LogLevelWarn, message, fields)
}

// LogError logs an error message
func LogError(message string, fields map[string]interface{}) {
	logMessage(LogLevelError, message, fields)
}

// sanitizePath sanitizes a file path to prevent directory traversal attacks
func sanitizePath(p string) string {
	// Remove any ".." to prevent directory traversal
	return filepath.Clean(p)
}

// isValidPath validates that a path is safe to use
func isValidPath(p string) bool {
	// Check if path is absolute or relative and does not contain ".." after cleaning
	if filepath.IsAbs(p) {
		return true
	}
	// For relative paths, ensure it's within the current working directory or a subdirectory
	cleanPath := filepath.Clean(p)
	return !strings.HasPrefix(cleanPath, "../") && cleanPath != ".."
}

// sanitizeString sanitizes a string to prevent injection attacks
func sanitizeString(s string) string {
	// Basic sanitization: trim spaces, remove control characters, limit length
	s = strings.TrimSpace(s)
	s = strings.Map(func(r rune) rune {
		if r >= 0x20 && r < 0x7F { // Printable ASCII characters
			return r
		}
		return -1 // Remove other characters
	}, s)
	if len(s) > 1024 { // Limit string length to prevent abuse
		s = s[:1024]
	}
	return s
}

// getIntOrDefault safely extracts an integer value from interface{} with default fallback
func getIntOrDefault(val interface{}, defaultVal int) int {
	if val == nil {
		return defaultVal
	}
	if f, ok := val.(float64); ok {
		return int(f)
	}
	if i, ok := val.(int); ok {
		return i
	}
	return defaultVal
}

// displayAuditResults formats and displays audit results
func displayAuditResults(result AuditResult, format, outputFile string, ciMode bool) {
	switch format {
	case "json":
		jsonOutput, err := json.MarshalIndent(result, "", "  ")
		if err != nil {
			fmt.Printf("‚ùå Error formatting JSON: %v\n", err)
			return
		}
		if outputFile != "" {
			os.WriteFile(outputFile, jsonOutput, 0644)
			if !ciMode {
				fmt.Printf("‚úÖ Report saved to %s\n", outputFile)
			}
		} else {
			fmt.Println(string(jsonOutput))
		}
		return
		
	case "html":
		htmlOutput := formatAuditResultsHTML(result)
		if outputFile != "" {
			os.WriteFile(outputFile, []byte(htmlOutput), 0644)
			if !ciMode {
				fmt.Printf("‚úÖ Report saved to %s\n", outputFile)
			}
		} else {
			fmt.Println(htmlOutput)
		}
		return
		
	case "markdown":
		markdownOutput := formatAuditResultsMarkdown(result)
		if outputFile != "" {
			os.WriteFile(outputFile, []byte(markdownOutput), 0644)
			if !ciMode {
				fmt.Printf("‚úÖ Report saved to %s\n", outputFile)
			}
		} else {
			fmt.Println(markdownOutput)
		}
		return
		
	default:
		// Text format (default)
		formatAuditResultsText(result, ciMode)
	}
}

// formatAuditResultsText formats results as human-readable text
func formatAuditResultsText(result AuditResult, ciMode bool) {
	if len(result.Findings) == 0 {
		return // Already printed "‚úÖ Audit PASSED" in runAudit()
	}
	
	// Group findings by type
	findingsByType := make(map[string][]AuditFinding)
	for _, finding := range result.Findings {
		findingsByType[finding.Type] = append(findingsByType[finding.Type], finding)
	}
	
	// Display findings grouped by type
	for _, findingType := range []string{"secrets", "sql_safety", "debug"} {
		if findings, ok := findingsByType[findingType]; ok {
			severity := "‚ö†Ô∏è"
			if findings[0].Severity == "critical" {
				severity = "‚ùå"
			}
			
		if ciMode {
				fmt.Printf("%s CRITICAL: %s found.\n", severity, strings.Title(strings.ReplaceAll(findingType, "_", " ")))
		} else {
				fmt.Printf("%s %s: %s found.\n", severity, strings.Title(strings.ReplaceAll(findingType, "_", " ")), findingType)
			}
			
			// Show first few findings
			maxShow := 5
			if ciMode {
				maxShow = 10
			}
			for i, finding := range findings {
				if i >= maxShow {
					fmt.Printf("  ... and %d more\n", len(findings)-maxShow)
					break
				}
				fmt.Printf("  %s:%d - %s\n", finding.File, finding.Line, finding.Message)
			}
		}
	}
}

// formatAuditResultsHTML formats results as HTML
func formatAuditResultsHTML(result AuditResult) string {
	var html strings.Builder
	html.WriteString("<!DOCTYPE html>\n<html><head><title>Sentinel Audit Report</title>")
	html.WriteString("<style>body{font-family:Arial,sans-serif;margin:20px;}h1{color:#333;}")
	html.WriteString(".finding{background:#f5f5f5;padding:10px;margin:5px 0;border-left:3px solid #ccc;}")
	html.WriteString(".critical{border-left-color:#d32f2f;}.warning{border-left-color:#f57c00;}")
	html.WriteString("</style></head><body>")
	html.WriteString("<h1>Sentinel Audit Report</h1>")
	html.WriteString(fmt.Sprintf("<p><strong>Status:</strong> %s</p>", map[bool]string{true: "‚úÖ PASSED", false: "‚ùå FAILED"}[result.Success]))
	html.WriteString(fmt.Sprintf("<p><strong>Timestamp:</strong> %s</p>", result.Timestamp))
	html.WriteString(fmt.Sprintf("<p><strong>Total Findings:</strong> %d</p>", len(result.Findings)))
	
	html.WriteString("<h2>Findings</h2>")
	for _, finding := range result.Findings {
		class := "warning"
		if finding.Severity == "critical" {
			class = "critical"
		}
		html.WriteString(fmt.Sprintf("<div class=\"finding %s\">", class))
		html.WriteString(fmt.Sprintf("<strong>%s</strong> (%s) - %s:%d<br>", finding.Message, finding.Severity, finding.File, finding.Line))
		if finding.Pattern != "" {
			html.WriteString(fmt.Sprintf("<code>%s</code>", finding.Pattern))
		}
		html.WriteString("</div>")
	}
	
	html.WriteString("</body></html>")
	return html.String()
}

// formatAuditResultsMarkdown formats results as Markdown
func formatAuditResultsMarkdown(result AuditResult) string {
	var md strings.Builder
	md.WriteString("# Sentinel Audit Report\n\n")
	md.WriteString(fmt.Sprintf("**Status:** %s\n\n", map[bool]string{true: "‚úÖ PASSED", false: "‚ùå FAILED"}[result.Success]))
	md.WriteString(fmt.Sprintf("**Timestamp:** %s\n\n", result.Timestamp))
	md.WriteString(fmt.Sprintf("**Total Findings:** %d\n\n", len(result.Findings)))
	
	md.WriteString("## Findings\n\n")
	for _, finding := range result.Findings {
		severity := "‚ö†Ô∏è"
		if finding.Severity == "critical" {
			severity = "‚ùå"
		}
		md.WriteString(fmt.Sprintf("### %s %s\n\n", severity, finding.Message))
		md.WriteString(fmt.Sprintf("- **File:** %s\n", finding.File))
		md.WriteString(fmt.Sprintf("- **Line:** %d\n", finding.Line))
		md.WriteString(fmt.Sprintf("- **Severity:** %s\n", finding.Severity))
		if finding.Pattern != "" {
			md.WriteString(fmt.Sprintf("- **Pattern:** `%s`\n", finding.Pattern))
		}
		md.WriteString("\n")
	}
	
	return md.String()
}

func runScribe() {
	// The Auto-Docs Engine
	cmd := exec.Command("sh", "-c", "find . -maxdepth 3 -not -path '*/.*' -not -path './node_modules*'")
	out, _ := cmd.Output()
	writeFile("docs/knowledge/file-structure.txt", string(out))
	fmt.Println("‚úÖ Context Map Updated.")
}

func runRefactor() {
	// NOTE: This feature is not yet implemented.
	// The refactor command is documented but functionality is deferred to a future phase.
	fmt.Println("‚ö†Ô∏è  Sentinel: Refactoring feature is not yet implemented.")
	fmt.Println("   This command is reserved for future legacy code migration functionality.")
	fmt.Println("   See IMPLEMENTATION_ROADMAP.md for planned features.")
}

// =============================================================================
// HTTP CLIENT FOR HUB COMMUNICATION (Phase 11)
// =============================================================================

type Config struct {
	HubURL string
	APIKey string
}

// =============================================================================
// MCP PROTOCOL TYPES (Phase 14B)
// =============================================================================

// MCPRequest represents a JSON-RPC 2.0 request
type MCPRequest struct {
	JSONRPC string          `json:"jsonrpc"` // "2.0"
	ID      interface{}     `json:"id"`
	Method  string          `json:"method"`
	Params  json.RawMessage `json:"params,omitempty"`
}

// MCPResponse represents a JSON-RPC 2.0 response
type MCPResponse struct {
	JSONRPC string      `json:"jsonrpc"` // "2.0"
	ID      interface{} `json:"id"`
	Result  interface{} `json:"result,omitempty"`
	Error   *MCPError   `json:"error,omitempty"`
}

// MCPError represents a JSON-RPC 2.0 error
type MCPError struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

// InitializeParams represents MCP initialize request parameters
type InitializeParams struct {
	ProtocolVersion string                 `json:"protocolVersion"`
	Capabilities    map[string]interface{} `json:"capabilities"`
	ClientInfo      map[string]string      `json:"clientInfo,omitempty"`
}

// InitializeResult represents MCP initialize response
type InitializeResult struct {
	ProtocolVersion string                 `json:"protocolVersion"`
	Capabilities    map[string]interface{} `json:"capabilities"`
	ServerInfo      map[string]string      `json:"serverInfo"`
}

// ToolCallParams represents MCP tool call parameters
type ToolCallParams struct {
	Name      string                 `json:"name"`
	Arguments map[string]interface{} `json:"arguments"`
}

// MCPTool represents a registered MCP tool
type MCPTool struct {
	Name        string                 `json:"name"`
	Description string                 `json:"description"`
	InputSchema map[string]interface{} `json:"inputSchema"`
}

// MCP Error Code Constants
const (
	// JSON-RPC 2.0 Standard Errors
	ParseErrorCode     = -32700
	InvalidRequestCode = -32600
	MethodNotFoundCode = -32601
	InvalidParamsCode  = -32602
	InternalErrorCode  = -32603
	
	// Custom Errors
	HubUnavailableCode = -32000
	HubTimeoutCode     = -32001
	ConfigErrorCode    = -32002
	
	// Task operation timeouts
	TaskGetTimeout    = 30 * time.Second
	TaskVerifyTimeout = 60 * time.Second
	TaskListTimeout   = 30 * time.Second
)

func loadConfig() *Config {
	config := &Config{
		HubURL: os.Getenv("SENTINEL_HUB_URL"),
		APIKey: os.Getenv("SENTINEL_API_KEY"),
	}
	
	// Check for --api-key flag (for CI/CD)
	for i, arg := range os.Args {
		if arg == "--api-key" && i+1 < len(os.Args) {
			config.APIKey = os.Args[i+1]
			break
		}
	}
	
	// Prefer environment variables, but allow file fallback
	// Try to read from .sentinelsrc file only if env vars not set
	if config.APIKey == "" {
	if configData, err := os.ReadFile(".sentinelsrc"); err == nil {
			// Check file permissions (should be 0600 or more restrictive)
			if fileInfo, err := os.Stat(".sentinelsrc"); err == nil {
				mode := fileInfo.Mode()
				// Check if file is world-readable (others have read permission)
				if mode&0004 != 0 || mode&0040 != 0 {
					fmt.Fprintf(os.Stderr, "‚ö†Ô∏è  WARNING: .sentinelsrc file permissions are too permissive (current: %s).\n", mode.String())
					fmt.Fprintf(os.Stderr, "   Recommendation: chmod 600 .sentinelsrc\n")
				}
			}
			
		var jsonConfig map[string]interface{}
		if json.Unmarshal(configData, &jsonConfig) == nil {
				if hubURL, ok := jsonConfig["hubUrl"].(string); ok && hubURL != "" && config.HubURL == "" {
				config.HubURL = hubURL
			}
			if apiKey, ok := jsonConfig["apiKey"].(string); ok && apiKey != "" {
				config.APIKey = apiKey
					// Warn about API key in file
					fmt.Fprintf(os.Stderr, "‚ö†Ô∏è  WARNING: API key found in .sentinelsrc file.\n")
					fmt.Fprintf(os.Stderr, "   Recommendation: Use environment variable SENTINEL_API_KEY instead for better security.\n")
				}
			}
		}
	}
	
	// Default Hub URL if not set
	if config.HubURL == "" {
		config.HubURL = "http://localhost:8080"
	}
	
	return config
}

func sendHTTPRequest(url, method string, headers map[string]string, body []byte) ([]byte, int, error) {
	return sendHTTPRequestWithRetry(url, method, headers, body, 3)
}

// CircuitBreaker implements circuit breaker pattern for Hub API calls
type CircuitBreaker struct {
	state         string // "closed", "open", "half-open"
	failureCount  int
	lastFailure   time.Time
	timeout       time.Duration
	mu            sync.Mutex
}

var hubCircuitBreaker = &CircuitBreaker{
	state:   "closed",
	timeout: 30 * time.Second,
}

func (cb *CircuitBreaker) canAttempt() bool {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	
	now := time.Now()
	
	switch cb.state {
	case "closed":
		return true
	case "open":
		// Check if timeout has passed
		if now.Sub(cb.lastFailure) >= cb.timeout {
			cb.state = "half-open"
			return true
		}
		return false
	case "half-open":
		return true
	default:
		return false
	}
}

func (cb *CircuitBreaker) recordSuccess() {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	
	cb.state = "closed"
	cb.failureCount = 0
}

func (cb *CircuitBreaker) recordFailure() {
	cb.mu.Lock()
	defer cb.mu.Unlock()
	
	cb.failureCount++
	cb.lastFailure = time.Now()
	
	if cb.state == "half-open" || cb.failureCount >= 3 {
		cb.state = "open"
	}
}

func sendHTTPRequestWithRetry(url, method string, headers map[string]string, body []byte, maxRetries int) ([]byte, int, error) {
	// Check circuit breaker
	if !hubCircuitBreaker.canAttempt() {
		return nil, 0, fmt.Errorf("circuit breaker is open - Hub API unavailable")
	}
	
	var lastErr error
	var lastStatusCode int
	var retryAfter time.Duration
	
	for attempt := 0; attempt <= maxRetries; attempt++ {
		if attempt > 0 {
			// Handle Retry-After header from previous attempt
			if retryAfter > 0 {
				time.Sleep(retryAfter)
				retryAfter = 0
			} else {
				// Exponential backoff with jitter: 100ms * 2^(attempt-1) + random jitter
				baseBackoff := time.Duration(100 * (1 << uint(attempt-1))) * time.Millisecond
				// Add jitter: ¬±20% of base backoff
				jitter := time.Duration(float64(baseBackoff) * 0.2 * (2.0*float64(time.Now().UnixNano()%100)/100.0 - 1.0))
				backoff := baseBackoff + jitter
			time.Sleep(backoff)
			}
		}
		
		client := &http.Client{
			Timeout: 10 * time.Second,
		}
		
		req, err := http.NewRequest(method, url, bytes.NewBuffer(body))
		if err != nil {
			hubCircuitBreaker.recordFailure()
			return nil, 0, err
		}
		
		for key, value := range headers {
			req.Header.Set(key, value)
		}
		
		resp, err := client.Do(req)
		if err != nil {
			lastErr = err
			// Retry on network errors
			if attempt < maxRetries {
				continue
			}
			hubCircuitBreaker.recordFailure()
			return nil, 0, err
		}
		defer resp.Body.Close()
		
		// Handle rate limiting (429)
		if resp.StatusCode == 429 {
			// Parse Retry-After header
			if retryAfterStr := resp.Header.Get("Retry-After"); retryAfterStr != "" {
				if secs, err := strconv.Atoi(retryAfterStr); err == nil {
					retryAfter = time.Duration(secs) * time.Second
				}
			}
			// Default to 1 second if no Retry-After header
			if retryAfter == 0 {
				retryAfter = time.Second
			}
			
			lastStatusCode = resp.StatusCode
			lastErr = fmt.Errorf("rate limit exceeded (429)")
			
			// Retry after waiting
			if attempt < maxRetries {
				continue
			}
			hubCircuitBreaker.recordFailure()
			return nil, resp.StatusCode, lastErr
		}
		
		// Retry on 5xx server errors, but not on 4xx client errors
		if resp.StatusCode >= 500 && attempt < maxRetries {
			lastStatusCode = resp.StatusCode
			lastErr = fmt.Errorf("server error %d", resp.StatusCode)
			continue
		}
		
		// Don't retry on 4xx errors (client errors)
		if resp.StatusCode >= 400 && resp.StatusCode < 500 {
			hubCircuitBreaker.recordFailure()
			respBody, _ := io.ReadAll(resp.Body)
			return respBody, resp.StatusCode, fmt.Errorf("client error %d: %s", resp.StatusCode, string(respBody))
		}
		
		// Success
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, resp.StatusCode, err
		}
		
		hubCircuitBreaker.recordSuccess()
		return respBody, resp.StatusCode, nil
	}
	
	hubCircuitBreaker.recordFailure()
	return nil, lastStatusCode, lastErr
}

// sendHTTPRequestWithTimeout sends HTTP request with configurable timeout
func sendHTTPRequestWithTimeout(url, method string, headers map[string]string, body []byte, maxRetries int, timeout time.Duration) ([]byte, int, error) {
	// Check circuit breaker
	if !hubCircuitBreaker.canAttempt() {
		return nil, 0, fmt.Errorf("circuit breaker is open - Hub API unavailable")
	}
	
	var lastErr error
	var lastStatusCode int
	var retryAfter time.Duration
	
	for attempt := 0; attempt <= maxRetries; attempt++ {
		if attempt > 0 {
			// Handle Retry-After header from previous attempt
			if retryAfter > 0 {
				time.Sleep(retryAfter)
				retryAfter = 0
			} else {
				// Exponential backoff with jitter: 100ms * 2^(attempt-1) + random jitter
				baseBackoff := time.Duration(100 * (1 << uint(attempt-1))) * time.Millisecond
				// Add jitter: ¬±20% of base backoff
				jitter := time.Duration(float64(baseBackoff) * 0.2 * (2.0*float64(time.Now().UnixNano()%100)/100.0 - 1.0))
				backoff := baseBackoff + jitter
				time.Sleep(backoff)
			}
		}
		
		client := &http.Client{
			Timeout: timeout,  // Use provided timeout
		}
		
		req, err := http.NewRequest(method, url, bytes.NewBuffer(body))
		if err != nil {
			hubCircuitBreaker.recordFailure()
			return nil, 0, err
		}
		
		for key, value := range headers {
			req.Header.Set(key, value)
		}
		
		resp, err := client.Do(req)
		if err != nil {
			lastErr = err
			// Retry on network errors
			if attempt < maxRetries {
				continue
			}
			hubCircuitBreaker.recordFailure()
			return nil, 0, err
		}
		defer resp.Body.Close()
		
		// Handle rate limiting (429)
		if resp.StatusCode == 429 {
			// Parse Retry-After header
			if retryAfterStr := resp.Header.Get("Retry-After"); retryAfterStr != "" {
				if secs, err := strconv.Atoi(retryAfterStr); err == nil {
					retryAfter = time.Duration(secs) * time.Second
				}
			}
			// Default to 1 second if no Retry-After header
			if retryAfter == 0 {
				retryAfter = time.Second
			}
			
			lastStatusCode = resp.StatusCode
			lastErr = fmt.Errorf("rate limit exceeded (429)")
			
			// Retry after waiting
			if attempt < maxRetries {
				continue
			}
		}
		
		// Read response body
		respBody, err := io.ReadAll(resp.Body)
		if err != nil {
			lastErr = err
			if attempt < maxRetries {
				continue
			}
			hubCircuitBreaker.recordFailure()
			return nil, resp.StatusCode, err
		}
		
		// Success - record and return
		if resp.StatusCode >= 200 && resp.StatusCode < 300 {
			hubCircuitBreaker.recordSuccess()
			return respBody, resp.StatusCode, nil
		}
		
		// Non-2xx status code
		lastStatusCode = resp.StatusCode
		lastErr = fmt.Errorf("HTTP %d: %s", resp.StatusCode, string(respBody))
		
		// Retry on 5xx errors
		if resp.StatusCode >= 500 && attempt < maxRetries {
			continue
		}
		
		// Don't retry on 4xx errors (except 429)
		hubCircuitBreaker.recordFailure()
		return respBody, resp.StatusCode, lastErr
	}
	
	hubCircuitBreaker.recordFailure()
	return nil, lastStatusCode, lastErr
}

// sendComprehensiveAnalysisRequest sends comprehensive analysis request with depth-based timeout
func sendComprehensiveAnalysisRequest(url, method string, headers map[string]string, body []byte, depth string) ([]byte, int, error) {
	// Calculate timeout based on depth
	timeout := 10 * time.Second
	switch depth {
	case "surface":
		timeout = 15 * time.Second
	case "medium":
		timeout = 60 * time.Second
	case "deep":
		timeout = 120 * time.Second
	}
	
	// Allow override via environment variable
	if timeoutStr := os.Getenv("SENTINEL_COMPREHENSIVE_TIMEOUT"); timeoutStr != "" {
		if duration, err := time.ParseDuration(timeoutStr); err == nil {
			timeout = duration
		}
	}
	
	return sendHTTPRequestWithTimeout(url, method, headers, body, 3, timeout)
}

func sendDocSyncRequest(reportType string, options map[string]interface{}) (map[string]interface{}, error) {
	config := loadConfig()
	
	if config.HubURL == "" || config.APIKey == "" {
		return nil, fmt.Errorf("Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
	}
	
	url := config.HubURL + "/api/v1/analyze/doc-sync"
	
	// Get project ID from config or use default
	projectID := "default"
	if projID, ok := options["project_id"].(string); ok {
		projectID = projID
	}
	
	requestBody := map[string]interface{}{
		"projectId":  projectID,
		"report_type": reportType,
		"options":     options,
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return nil, err
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
	if err != nil {
		return nil, fmt.Errorf("Hub request failed: %v", err)
	}
	
	if statusCode != http.StatusOK {
		return nil, fmt.Errorf("Hub returned status %d: %s", statusCode, string(respBody))
	}
	
	var response map[string]interface{}
	if err := json.Unmarshal(respBody, &response); err != nil {
		return nil, err
	}
	
	return response, nil
}

// =============================================================================
// DOC-SYNC COMMAND HANDLER (Phase 11)
// =============================================================================

func runDocSync() {
	// Parse flags
	args := os.Args[2:]
	reportType := "status_tracking"
	fixMode := false
	outputFormat := "text"
	outputFile := ""
	
	for i, arg := range args {
		switch arg {
		case "--fix":
			fixMode = true
		case "--output":
			if i+1 < len(args) {
				outputFormat = args[i+1]
			}
		case "--output-file":
			if i+1 < len(args) {
				outputFile = args[i+1]
			}
		case "--type":
			if i+1 < len(args) {
				reportType = args[i+1]
			}
		}
	}
	
	options := map[string]interface{}{
		"codebase_path": ".",
		"fix":           fixMode,
	}
	
	// Send request to Hub
	fmt.Println("üìã Checking documentation-code sync...")
	response, err := sendDocSyncRequest(reportType, options)
	if err != nil {
		fmt.Printf("‚ö†Ô∏è  Doc-sync check failed: %v\n", err)
		fmt.Println("   (Continuing without doc-sync check)")
		return
	}
	
	// Display results
	if success, ok := response["success"].(bool); ok && success {
		displayDocSyncResults(response, outputFormat, outputFile, fixMode)
	} else {
		msg := "Unknown error"
		if message, ok := response["message"].(string); ok {
			msg = message
		}
		fmt.Printf("‚ùå Doc-sync analysis failed: %s\n", msg)
	}
}

func displayDocSyncResults(response map[string]interface{}, format, outputFile string, fixMode bool) {
	if format == "json" {
		jsonOutput, _ := json.MarshalIndent(response, "", "  ")
		if outputFile != "" {
			os.WriteFile(outputFile, jsonOutput, 0644)
			fmt.Printf("‚úÖ Report saved to %s\n", outputFile)
		} else {
			fmt.Println(string(jsonOutput))
		}
		return
	}
	
	// Human-readable format
	fmt.Println("\nüìã Documentation-Code Sync Report")
	fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	
	// In-sync items
	if inSync, ok := response["in_sync"].([]interface{}); ok {
		fmt.Println("\n‚úÖ IN SYNC:")
		if len(inSync) == 0 {
			fmt.Println("  (none)")
		} else {
			for _, item := range inSync {
				if itemMap, ok := item.(map[string]interface{}); ok {
					phase := ""
					status := ""
					if p, ok := itemMap["phase"].(string); ok {
						phase = p
					}
					if s, ok := itemMap["status"].(string); ok {
						status = s
					}
					fmt.Printf("  - %s (%s)\n", phase, status)
				}
			}
		}
	}
	
	// Discrepancies
	if discrepancies, ok := response["discrepancies"].([]interface{}); ok {
		fmt.Println("\n‚ö†Ô∏è  DISCREPANCIES FOUND:\n")
		if len(discrepancies) == 0 {
			fmt.Println("  (none)")
		} else {
			for _, disc := range discrepancies {
				if discMap, ok := disc.(map[string]interface{}); ok {
					phase := ""
					discType := ""
					docStatus := ""
					codeStatus := ""
					recommendation := ""
					
					if p, ok := discMap["phase"].(string); ok {
						phase = p
					}
					if t, ok := discMap["type"].(string); ok {
						discType = t
					}
					if ds, ok := discMap["doc_status"].(string); ok {
						docStatus = ds
					}
					if cs, ok := discMap["code_status"].(string); ok {
						codeStatus = cs
					}
					if r, ok := discMap["recommendation"].(string); ok {
						recommendation = r
					}
					
					fmt.Printf("  %s: %s\n", phase, discType)
					fmt.Printf("    Documentation: %s\n", docStatus)
					fmt.Printf("    Code: %s\n", codeStatus)
					fmt.Printf("    Recommendation: %s\n", recommendation)
					fmt.Println()
				}
			}
		}
	}
	
	// Summary
	if summary, ok := response["summary"].(map[string]interface{}); ok {
		fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
		totalPhases := 0
		inSyncCount := 0
		discrepancyCount := 0
		
		if tp, ok := summary["total_phases"].(float64); ok {
			totalPhases = int(tp)
		}
		if isc, ok := summary["in_sync_count"].(float64); ok {
			inSyncCount = int(isc)
		}
		if dc, ok := summary["discrepancy_count"].(float64); ok {
			discrepancyCount = int(dc)
		}
		
		fmt.Printf("Summary: %d phases, %d in sync, %d discrepancies\n",
			totalPhases, inSyncCount, discrepancyCount)
	}
	
	if fixMode {
		fmt.Println("\nüí° Use --fix flag to apply suggested updates")
	}
}

// =============================================================================
// KNOWLEDGE COMMAND HANDLER (Phase 12)
// =============================================================================

func runKnowledge() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: ./sentinel knowledge <subcommand>")
		fmt.Println("Subcommands:")
		fmt.Println("  gap-analysis  - Find gaps between documentation and code")
		fmt.Println("  changes       - List change requests")
		fmt.Println("  approve       - Approve change request")
		fmt.Println("  reject        - Reject change request")
		fmt.Println("  impact        - Show impact analysis")
		fmt.Println("  track         - Show implementation status")
		fmt.Println("  start         - Start implementation")
		fmt.Println("  complete      - Mark implementation as complete")
		return
	}
	
	subcommand := os.Args[2]
	
	switch subcommand {
	case "gap-analysis":
		runGapAnalysis()
	case "changes":
		runChangeRequests()
	case "approve":
		runApproveChangeRequest()
	case "reject":
		runRejectChangeRequest()
	case "impact":
		runImpactAnalysis()
	case "track":
		runTrackImplementation()
	case "start":
		runStartImplementation()
	case "complete":
		runCompleteImplementation()
	default:
		fmt.Printf("Unknown subcommand: %s\n", subcommand)
		runKnowledge() // Show help
	}
}

func runGapAnalysis() {
	args := os.Args[3:]
	outputFormat := "text"
	outputFile := ""
	includeTests := true
	reverseCheck := false
	
	for i, arg := range args {
		switch arg {
		case "--output":
			if i+1 < len(args) {
				outputFormat = args[i+1]
			}
		case "--output-file":
			if i+1 < len(args) {
				outputFile = args[i+1]
			}
		case "--no-tests":
			includeTests = false
		case "--reverse-check":
			reverseCheck = true
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	url := config.HubURL + "/api/v1/knowledge/gap-analysis"
	
	requestBody := map[string]interface{}{
		"projectId":    "default",
		"codebasePath": ".",
		"options": map[string]interface{}{
			"includeTests": includeTests,
			"reverseCheck": reverseCheck,
		},
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		fmt.Printf("‚ùå Failed to prepare request: %v\n", err)
		return
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Println("üîç Analyzing gaps between documentation and code...")
	respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
	if err != nil {
		fmt.Printf("‚ùå Gap analysis failed: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	var response map[string]interface{}
	if err := json.Unmarshal(respBody, &response); err != nil {
		fmt.Printf("‚ùå Failed to parse response: %v\n", err)
		return
	}
	
	if success, ok := response["success"].(bool); ok && success {
		displayGapAnalysisResults(response, outputFormat, outputFile)
	} else {
		fmt.Println("‚ùå Gap analysis failed")
	}
}

func displayGapAnalysisResults(response map[string]interface{}, format, outputFile string) {
	report, ok := response["report"].(map[string]interface{})
	if !ok {
		fmt.Println("‚ùå Invalid response format")
		return
	}
	
	if format == "json" {
		jsonOutput, _ := json.MarshalIndent(response, "", "  ")
		if outputFile != "" {
			os.WriteFile(outputFile, jsonOutput, 0644)
			fmt.Printf("‚úÖ Report saved to %s\n", outputFile)
		} else {
			fmt.Println(string(jsonOutput))
		}
		return
	}
	
	// Text format
	gaps, _ := report["gaps"].([]interface{})
	summary, _ := report["summary"].(map[string]interface{})
	
	fmt.Println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	fmt.Println("Gap Analysis Report")
	fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	
	if summary != nil {
		total, _ := summary["total"].(float64)
		fmt.Printf("\nTotal Gaps Found: %.0f\n", total)
		
		byType, _ := summary["by_type"].(map[string]interface{})
		if byType != nil {
			fmt.Println("\nBy Type:")
			if missingImpl, ok := byType["missing_impl"].(float64); ok {
				fmt.Printf("  Missing Implementation: %.0f\n", missingImpl)
			}
			if missingDoc, ok := byType["missing_doc"].(float64); ok {
				fmt.Printf("  Missing Documentation: %.0f\n", missingDoc)
			}
			if partial, ok := byType["partial_match"].(float64); ok {
				fmt.Printf("  Partial Match: %.0f\n", partial)
			}
			if testsMissing, ok := byType["tests_missing"].(float64); ok {
				fmt.Printf("  Tests Missing: %.0f\n", testsMissing)
			}
		}
	}
	
	if len(gaps) > 0 {
		fmt.Println("\nGaps:")
		for i, gap := range gaps {
			gapMap, _ := gap.(map[string]interface{})
			if gapMap == nil {
				continue
			}
			
			gapType, _ := gapMap["type"].(string)
			ruleTitle, _ := gapMap["rule_title"].(string)
			description, _ := gapMap["description"].(string)
			recommendation, _ := gapMap["recommendation"].(string)
			
			fmt.Printf("\n%d. [%s] %s\n", i+1, gapType, ruleTitle)
			fmt.Printf("   Description: %s\n", description)
			fmt.Printf("   Recommendation: %s\n", recommendation)
		}
	} else {
		fmt.Println("\n‚úÖ No gaps found!")
	}
}

func runChangeRequests() {
	args := os.Args[3:]
	statusFilter := ""
	limit := 50
	offset := 0
	
	for i, arg := range args {
		switch arg {
		case "--status":
			if i+1 < len(args) {
				statusFilter = args[i+1]
			}
		case "--limit":
			if i+1 < len(args) {
				fmt.Sscanf(args[i+1], "%d", &limit)
			}
		case "--offset":
			if i+1 < len(args) {
				fmt.Sscanf(args[i+1], "%d", &offset)
			}
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	url := config.HubURL + "/api/v1/change-requests"
	if statusFilter != "" {
		url += "?status=" + statusFilter
	}
	if limit > 0 {
		if strings.Contains(url, "?") {
			url += "&"
		} else {
			url += "?"
		}
		url += fmt.Sprintf("limit=%d&offset=%d", limit, offset)
	}
	
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Println("üìã Fetching change requests...")
	respBody, statusCode, err := sendHTTPRequest(endpointURL, "GET", headers, nil)
	if err != nil {
		fmt.Printf("‚ùå Failed to fetch change requests: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	var response map[string]interface{}
	if err := json.Unmarshal(respBody, &response); err != nil {
		fmt.Printf("‚ùå Failed to parse response: %v\n", err)
		return
	}
	
	displayChangeRequests(response)
}

func displayChangeRequests(response map[string]interface{}) {
	requests, _ := response["change_requests"].([]interface{})
	total, _ := response["total"].(float64)
	
	fmt.Println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	fmt.Println("Change Requests")
	fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	fmt.Printf("Total: %.0f\n\n", total)
	
	if len(requests) == 0 {
		fmt.Println("No change requests found.")
		return
	}
	
	for i, req := range requests {
		reqMap, _ := req.(map[string]interface{})
		if reqMap == nil {
			continue
		}
		
		id, _ := reqMap["id"].(string)
		crType, _ := reqMap["type"].(string)
		status, _ := reqMap["status"].(string)
		implStatus, _ := reqMap["implementation_status"].(string)
		
		fmt.Printf("%d. %s [%s] - Status: %s", i+1, id, crType, status)
		if implStatus != "" {
			fmt.Printf(", Implementation: %s", implStatus)
		}
		fmt.Println()
	}
}

func runApproveChangeRequest() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: ./sentinel knowledge approve <CR-ID> [--by <email>]")
		return
	}
	
	changeRequestID := os.Args[3]
	approvedBy := "system"
	
	args := os.Args[4:]
	for i, arg := range args {
		if arg == "--by" && i+1 < len(args) {
			approvedBy = args[i+1]
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	url := config.HubURL + "/api/v1/change-requests/" + changeRequestID + "/approve"
	
	requestBody := map[string]interface{}{
		"approved_by": approvedBy,
	}
	
	jsonBody, _ := json.Marshal(requestBody)
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Printf("‚úÖ Approving change request %s...\n", changeRequestID)
	respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
	if err != nil {
		fmt.Printf("‚ùå Failed to approve: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	fmt.Println("‚úÖ Change request approved successfully")
}

func runRejectChangeRequest() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: ./sentinel knowledge reject <CR-ID> [--reason <reason>] [--by <email>]")
		return
	}
	
	changeRequestID := os.Args[3]
	reason := "No reason provided"
	rejectedBy := "system"
	
	args := os.Args[4:]
	for i, arg := range args {
		if arg == "--reason" && i+1 < len(args) {
			reason = args[i+1]
		}
		if arg == "--by" && i+1 < len(args) {
			rejectedBy = args[i+1]
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	url := config.HubURL + "/api/v1/change-requests/" + changeRequestID + "/reject"
	
	requestBody := map[string]interface{}{
		"rejected_by": rejectedBy,
		"reason":      reason,
	}
	
	jsonBody, _ := json.Marshal(requestBody)
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Printf("‚ùå Rejecting change request %s...\n", changeRequestID)
	respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
	if err != nil {
		fmt.Printf("‚ùå Failed to reject: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	fmt.Println("‚úÖ Change request rejected")
}

func runImpactAnalysis() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: ./sentinel knowledge impact <CR-ID> [--codebase-path <path>]")
		return
	}
	
	changeRequestID := os.Args[3]
	codebasePath := "."
	
	args := os.Args[4:]
	for i, arg := range args {
		if arg == "--codebase-path" && i+1 < len(args) {
			codebasePath = args[i+1]
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	url := config.HubURL + "/api/v1/change-requests/" + changeRequestID + "/impact"
	
	requestBody := map[string]interface{}{
		"codebasePath": codebasePath,
	}
	
	jsonBody, _ := json.Marshal(requestBody)
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Printf("üîç Analyzing impact for change request %s...\n", changeRequestID)
	respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
	if err != nil {
		fmt.Printf("‚ùå Failed to analyze impact: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	var response map[string]interface{}
	if err := json.Unmarshal(respBody, &response); err != nil {
		fmt.Printf("‚ùå Failed to parse response: %v\n", err)
		return
	}
	
	displayImpactAnalysis(response)
}

func displayImpactAnalysis(response map[string]interface{}) {
	impact, _ := response["impact"].(map[string]interface{})
	if impact == nil {
		fmt.Println("‚ùå Invalid impact analysis response")
		return
	}
	
	fmt.Println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	fmt.Println("Impact Analysis")
	fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	
	affectedCode, _ := impact["affected_code"].([]interface{})
	affectedTests, _ := impact["affected_tests"].([]interface{})
	estimatedEffort, _ := impact["estimated_effort"].(string)
	
	fmt.Printf("\nEstimated Effort: %s\n", estimatedEffort)
	
	if len(affectedCode) > 0 {
		fmt.Println("\nAffected Code:")
		for i, code := range affectedCode {
			codeMap, _ := code.(map[string]interface{})
			if codeMap != nil {
				filePath, _ := codeMap["file_path"].(string)
				funcName, _ := codeMap["function_name"].(string)
				fmt.Printf("  %d. %s", i+1, filePath)
				if funcName != "" {
					fmt.Printf(" (%s)", funcName)
				}
				fmt.Println()
			}
		}
	}
	
	if len(affectedTests) > 0 {
		fmt.Println("\nAffected Tests:")
		for i, test := range affectedTests {
			testMap, _ := test.(map[string]interface{})
			if testMap != nil {
				filePath, _ := testMap["file_path"].(string)
				testName, _ := testMap["test_name"].(string)
				fmt.Printf("  %d. %s", i+1, filePath)
				if testName != "" {
					fmt.Printf(" (%s)", testName)
				}
				fmt.Println()
			}
		}
	}
}

func runTrackImplementation() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: ./sentinel knowledge track <CR-ID>")
		return
	}
	
	changeRequestID := os.Args[3]
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	url := config.HubURL + "/api/v1/change-requests/" + changeRequestID
	
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Printf("üìä Tracking implementation for change request %s...\n", changeRequestID)
	respBody, statusCode, err := sendHTTPRequest(endpointURL, "GET", headers, nil)
	if err != nil {
		fmt.Printf("‚ùå Failed to track: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	var cr map[string]interface{}
	if err := json.Unmarshal(respBody, &cr); err != nil {
		fmt.Printf("‚ùå Failed to parse response: %v\n", err)
		return
	}
	
	displayImplementationStatus(cr)
}

func displayImplementationStatus(cr map[string]interface{}) {
	fmt.Println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	fmt.Println("Implementation Status")
	fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	
	id, _ := cr["id"].(string)
	status, _ := cr["status"].(string)
	implStatus, _ := cr["implementation_status"].(string)
	implNotes, _ := cr["implementation_notes"].(string)
	
	fmt.Printf("Change Request: %s\n", id)
	fmt.Printf("Status: %s\n", status)
	fmt.Printf("Implementation Status: %s\n", implStatus)
	if implNotes != "" {
		fmt.Printf("Notes: %s\n", implNotes)
	}
}

func runStartImplementation() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: ./sentinel knowledge start <CR-ID> [--notes <notes>]")
		return
	}
	
	changeRequestID := os.Args[3]
	notes := ""
	
	args := os.Args[4:]
	for i, arg := range args {
		if arg == "--notes" && i+1 < len(args) {
			notes = args[i+1]
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	url := config.HubURL + "/api/v1/change-requests/" + changeRequestID + "/start"
	
	requestBody := map[string]interface{}{
		"notes": notes,
	}
	
	jsonBody, _ := json.Marshal(requestBody)
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Printf("üöÄ Starting implementation for change request %s...\n", changeRequestID)
	respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
	if err != nil {
		fmt.Printf("‚ùå Failed to start: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	fmt.Println("‚úÖ Implementation started")
}

func runCompleteImplementation() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: ./sentinel knowledge complete <CR-ID> [--notes <notes>]")
		return
	}
	
	changeRequestID := os.Args[3]
	notes := ""
	
	args := os.Args[4:]
	for i, arg := range args {
		if arg == "--notes" && i+1 < len(args) {
			notes = args[i+1]
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	url := config.HubURL + "/api/v1/change-requests/" + changeRequestID + "/complete"
	
	requestBody := map[string]interface{}{
		"notes": notes,
	}
	
	jsonBody, _ := json.Marshal(requestBody)
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Printf("‚úÖ Completing implementation for change request %s...\n", changeRequestID)
	respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
	if err != nil {
		fmt.Printf("‚ùå Failed to complete: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	fmt.Println("‚úÖ Implementation completed")
}

// =============================================================================
// TASKS COMMAND HANDLER (Phase 14E)
// =============================================================================

func runTasks() {
	if len(os.Args) < 3 {
		fmt.Println("Usage: ./sentinel tasks <subcommand>")
		fmt.Println("Subcommands:")
		fmt.Println("  scan         - Scan codebase for tasks")
		fmt.Println("  list         - List all tasks")
		fmt.Println("  verify       - Verify task completion")
		fmt.Println("  dependencies - Show dependency graph")
		fmt.Println("  complete     - Manually mark task complete")
		return
	}
	
	subcommand := os.Args[2]
	
	switch subcommand {
	case "scan":
		runTasksScan()
	case "list":
		runTasksList()
	case "verify":
		runTasksVerify()
	case "dependencies":
		runTasksDependencies()
	case "complete":
		runTasksComplete()
	default:
		fmt.Printf("Unknown subcommand: %s\n", subcommand)
		runTasks() // Show help
	}
}

func runTasksScan() {
	args := os.Args[3:]
	codebasePath := "."
	
	for i, arg := range args {
		if arg == "--dir" && i+1 < len(args) {
			codebasePath = args[i+1]
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	absPath, _ := filepath.Abs(codebasePath)
	
	url := config.HubURL + "/api/v1/tasks/scan"
	requestBody := map[string]interface{}{
		"codebasePath": absPath,
	}
	
	jsonBody, _ := json.Marshal(requestBody)
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Printf("üîç Scanning codebase for tasks in %s...\n", absPath)
	respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
	if err != nil {
		fmt.Printf("‚ùå Failed to scan: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	var result map[string]interface{}
	if err := json.Unmarshal(respBody, &result); err != nil {
		fmt.Printf("‚ùå Failed to parse response: %v\n", err)
		return
	}
	
	detected, _ := result["detected"].(float64)
	unique, _ := result["unique"].(float64)
	stored, _ := result["stored"].(float64)
	
	fmt.Printf("‚úÖ Scan complete: %d detected, %d unique, %d stored\n", int(detected), int(unique), int(stored))
}

func runTasksList() {
	args := os.Args[3:]
	statusFilter := ""
	priorityFilter := ""
	limit := 50
	
	for i, arg := range args {
		if arg == "--status" && i+1 < len(args) {
			statusFilter = args[i+1]
		}
		if arg == "--priority" && i+1 < len(args) {
			priorityFilter = args[i+1]
		}
		if arg == "--limit" && i+1 < len(args) {
			if l, err := strconv.Atoi(args[i+1]); err == nil {
				limit = l
			}
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	tasksURL := config.HubURL + "/api/v1/tasks"
	queryParams := urlpkg.Values{}
	if statusFilter != "" {
		queryParams.Add("status", statusFilter)
	}
	if priorityFilter != "" {
		queryParams.Add("priority", priorityFilter)
	}
	queryParams.Add("limit", strconv.Itoa(limit))
	
	if len(queryParams) > 0 {
		tasksURL += "?" + queryParams.Encode()
	}
	
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}
	
	respBody, statusCode, err := sendHTTPRequest(tasksURL, "GET", headers, nil)
	if err != nil {
		fmt.Printf("‚ùå Failed to list tasks: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	var response map[string]interface{}
	if err := json.Unmarshal(respBody, &response); err != nil {
		fmt.Printf("‚ùå Failed to parse response: %v\n", err)
		return
	}
	
	tasks, _ := response["tasks"].([]interface{})
	total, _ := response["total"].(float64)
	
	fmt.Printf("\nüìã Tasks (%d total)\n", int(total))
	fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	
	if len(tasks) == 0 {
		fmt.Println("  (no tasks found)")
		return
	}
	
	for _, taskInterface := range tasks {
		if task, ok := taskInterface.(map[string]interface{}); ok {
			id, _ := task["id"].(string)
			title, _ := task["title"].(string)
			status, _ := task["status"].(string)
			priority, _ := task["priority"].(string)
			filePath, _ := task["file_path"].(string)
			
			statusIcon := "‚è≥"
			if status == "completed" {
				statusIcon = "‚úÖ"
			} else if status == "in_progress" {
				statusIcon = "üîÑ"
			} else if status == "blocked" {
				statusIcon = "üö´"
			}
			
			priorityIcon := "‚ö™"
			if priority == "critical" {
				priorityIcon = "üî¥"
			} else if priority == "high" {
				priorityIcon = "üü†"
			} else if priority == "medium" {
				priorityIcon = "üü°"
			}
			
			fmt.Printf("%s %s [%s] %s\n", statusIcon, priorityIcon, status, title)
			if filePath != "" {
				fmt.Printf("   üìÅ %s\n", filePath)
			}
			fmt.Printf("   üÜî %s\n\n", id)
		}
	}
}

func runTasksVerify() {
	args := os.Args[3:]
	verifyAll := false
	taskID := ""
	force := false

	for _, arg := range args {
		if arg == "--all" {
			verifyAll = true
		}
		if arg == "--force" {
			force = true
		}
		if !strings.HasPrefix(arg, "--") && taskID == "" {
			taskID = arg
		}
	}
	
	if !verifyAll && taskID == "" {
		fmt.Println("Usage: ./sentinel tasks verify <TASK-ID> [--force]")
		fmt.Println("   or: ./sentinel tasks verify --all [--force]")
		return
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	if verifyAll {
		fmt.Println("üîç Verifying all pending tasks...")
		url := config.HubURL + "/api/v1/tasks/verify-all"
		requestBody := map[string]interface{}{
			"force": force,
		}
		
		jsonBody, _ := json.Marshal(requestBody)
		headers := map[string]string{
			"Content-Type":  "application/json",
			"Authorization": "Bearer " + config.APIKey,
		}
		
		respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
		if err != nil {
			fmt.Printf("‚ùå Failed to verify all tasks: %v\n", err)
			return
		}
		
		if statusCode != 200 {
			fmt.Printf("‚ùå Verification failed (status %d): %s\n", statusCode, string(respBody))
			return
		}
		
		var result map[string]interface{}
		if err := json.Unmarshal(respBody, &result); err != nil {
			fmt.Printf("‚ùå Failed to parse response: %v\n", err)
			return
		}
		
		total, _ := result["total"].(float64)
		verified, _ := result["verified"].(float64)
		failed, _ := result["failed"].(float64)
		skipped, _ := result["skipped"].(float64)
		
		fmt.Printf("‚úÖ Verification complete:\n")
		fmt.Printf("   Total: %d\n", int(total))
		fmt.Printf("   Verified: %d\n", int(verified))
		fmt.Printf("   Failed: %d\n", int(failed))
		fmt.Printf("   Skipped: %d\n", int(skipped))
	} else {
		url := config.HubURL + "/api/v1/tasks/" + taskID + "/verify"
		requestBody := map[string]interface{}{
			"force": force,
		}
		
		jsonBody, _ := json.Marshal(requestBody)
		headers := map[string]string{
			"Content-Type":  "application/json",
			"Authorization": "Bearer " + config.APIKey,
		}
		
		fmt.Printf("üîç Verifying task %s...\n", taskID)
		respBody, statusCode, err := sendHTTPRequest(url, "POST", headers, jsonBody)
		if err != nil {
			fmt.Printf("‚ùå Failed to verify: %v\n", err)
			return
		}
		
		if statusCode != http.StatusOK {
			fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
			return
		}
		
		var result map[string]interface{}
		if err := json.Unmarshal(respBody, &result); err != nil {
			fmt.Printf("‚ùå Failed to parse response: %v\n", err)
			return
		}
		
		confidence, _ := result["overall_confidence"].(float64)
		status, _ := result["status"].(string)
		
		fmt.Printf("‚úÖ Verification complete: %.0f%% confidence, status: %s\n", confidence*100, status)
	}
}

func runTasksDependencies() {
	args := os.Args[3:]
	taskID := ""
	
	if len(args) > 0 && !strings.HasPrefix(args[0], "--") {
		taskID = args[0]
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	if taskID == "" {
		fmt.Println("Usage: ./sentinel tasks dependencies [TASK-ID]")
		fmt.Println("‚ö†Ô∏è  Dependency graph visualization not yet implemented")
		return
	}
	
	url := config.HubURL + "/api/v1/tasks/" + taskID + "/dependencies"
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}
	
	fmt.Printf("üîç Fetching dependencies for task %s...\n", taskID)
	respBody, statusCode, err := sendHTTPRequest(endpointURL, "GET", headers, nil)
	if err != nil {
		fmt.Printf("‚ùå Failed to get dependencies: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	var result map[string]interface{}
	if err := json.Unmarshal(respBody, &result); err != nil {
		fmt.Printf("‚ùå Failed to parse response: %v\n", err)
		return
	}
	
	dependencies, _ := result["dependencies"].([]interface{})
	blockedBy, _ := result["blocked_by"].([]interface{})
	blocks, _ := result["blocks"].([]interface{})
	
	fmt.Printf("\nüìä Dependencies for task %s\n", taskID)
	fmt.Println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê")
	
	if len(blockedBy) > 0 {
		fmt.Println("\nüö´ Blocked by:")
		for _, depID := range blockedBy {
			fmt.Printf("  - %v\n", depID)
		}
	}
	
	if len(blocks) > 0 {
		fmt.Println("\nüîí Blocks:")
		for _, depID := range blocks {
			fmt.Printf("  - %v\n", depID)
		}
	}
	
	if len(dependencies) > 0 {
		fmt.Println("\nüì¶ Dependencies:")
		for _, depInterface := range dependencies {
			if dep, ok := depInterface.(map[string]interface{}); ok {
				depID, _ := dep["depends_on_task_id"].(string)
				depType, _ := dep["dependency_type"].(string)
				confidence, _ := dep["confidence"].(float64)
				fmt.Printf("  - %s (%s, %.0f%% confidence)\n", depID, depType, confidence*100)
			}
		}
	}
	
	if len(blockedBy) == 0 && len(blocks) == 0 && len(dependencies) == 0 {
		fmt.Println("  (no dependencies)")
	}
}

func runTasksComplete() {
	if len(os.Args) < 4 {
		fmt.Println("Usage: ./sentinel tasks complete <TASK-ID> [--reason <reason>]")
		return
	}
	
	taskID := os.Args[3]
	reason := "" // Reason for task completion
	
	args := os.Args[4:]
	for i, arg := range args {
		if arg == "--reason" && i+1 < len(args) {
			reason = args[i+1]
		}
	}
	
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		fmt.Println("‚ùå Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY")
		return
	}
	
	// Get current task to get version
	url := config.HubURL + "/api/v1/tasks/" + taskID
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}
	
	respBody, statusCode, err := sendHTTPRequest(endpointURL, "GET", headers, nil)
	if err != nil {
		fmt.Printf("‚ùå Failed to get task: %v\n", err)
		return
	}
	
	if statusCode != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", statusCode, string(respBody))
		return
	}
	
	var task map[string]interface{}
	if err := json.Unmarshal(respBody, &task); err != nil {
		fmt.Printf("‚ùå Failed to parse task: %v\n", err)
		return
	}
	
	version, _ := task["version"].(float64)
	
	// Update task status to completed
	updateURL := config.HubURL + "/api/v1/tasks/" + taskID
	requestBody := map[string]interface{}{
		"status":  "completed",
		"version": int(version),
	}
	
	jsonBody, _ := json.Marshal(requestBody)
	headers["Content-Type"] = "application/json"
	
	fmt.Printf("‚úÖ Marking task %s as complete...\n", taskID)
	updateResp, updateStatus, err := sendHTTPRequest(updateURL, "PUT", headers, jsonBody)
	if err != nil {
		fmt.Printf("‚ùå Failed to complete task: %v\n", err)
		return
	}
	
	if updateStatus != http.StatusOK {
		fmt.Printf("‚ùå Hub returned status %d: %s\n", updateStatus, string(updateResp))
		return
	}
	
	fmt.Println("‚úÖ Task marked as complete")
}

// =============================================================================
// MCP SERVER IMPLEMENTATION (Phase 14B)
// =============================================================================

// registeredTools contains all available MCP tools
var registeredTools = []MCPTool{
	{
		Name:        "sentinel_analyze_feature_comprehensive",
		Description: "Perform comprehensive analysis of a feature across all layers (UI, API, Database, Logic, Integration, Tests) with business context validation",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"feature": map[string]interface{}{
					"type":        "string",
					"description": "Feature name or description (e.g., 'Order Cancellation')",
				},
				"mode": map[string]interface{}{
					"type":        "string",
					"enum":        []string{"auto", "manual"},
					"description": "Auto-discover feature components or use manual file specification",
					"default":     "auto",
				},
				"files": map[string]interface{}{
					"type":        "object",
					"description": "Manual file specification (required if mode='manual')",
					"properties": map[string]interface{}{
						"ui":         map[string]interface{}{"type": "array", "items": map[string]interface{}{"type": "string"}},
						"api":        map[string]interface{}{"type": "array", "items": map[string]interface{}{"type": "string"}},
						"database":   map[string]interface{}{"type": "array", "items": map[string]interface{}{"type": "string"}},
						"logic":      map[string]interface{}{"type": "array", "items": map[string]interface{}{"type": "string"}},
						"integration": map[string]interface{}{"type": "array", "items": map[string]interface{}{"type": "string"}},
						"tests":      map[string]interface{}{"type": "array", "items": map[string]interface{}{"type": "string"}},
					},
				},
				"codebasePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to codebase root (required for auto mode, optional for manual)",
				},
				"depth": map[string]interface{}{
					"type":        "string",
					"enum":        []string{"surface", "medium", "deep"},
					"description": "Analysis depth (surface=fast, medium=balanced, deep=comprehensive)",
					"default":     "medium",
				},
				"includeBusinessContext": map[string]interface{}{
					"type":        "boolean",
					"description": "Include business rules, journeys, and entities validation",
					"default":     false,
				},
			},
			"required": []string{"feature"},
		},
	},
	{
		Name:        "sentinel_check_intent",
		Description: "Analyze unclear prompts and generate clarifying questions. Handles vague requests gracefully by understanding intent and asking for clarification.",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"prompt": map[string]interface{}{
					"type":        "string",
					"description": "User prompt to analyze for clarity",
				},
				"codebasePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to codebase root (optional, for context gathering)",
				},
				"includeContext": map[string]interface{}{
					"type":        "boolean",
					"description": "Include context gathering (recent files, git status, etc.)",
					"default":     true,
				},
			},
			"required": []string{"prompt"},
		},
	},
	{
		Name:        "sentinel_analyze_intent",
		Description: "Analyze user intent and return context, rules, security, and test requirements",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"request": map[string]interface{}{
					"type":        "string",
					"description": "User's request to analyze",
				},
				"recentFiles": map[string]interface{}{
					"type":        "array",
					"items":       map[string]interface{}{"type": "string"},
					"description": "Recently edited files (optional)",
				},
				"gitStatus": map[string]interface{}{
					"type":        "object",
					"description": "Current git status (optional)",
				},
				"codebasePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to codebase root (optional)",
				},
			},
			"required": []string{"request"},
		},
	},
	{
		Name:        "sentinel_get_context",
		Description: "Get recent activity context including git status, recent commits, and error logs",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"codebasePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to codebase root (optional, defaults to current directory)",
				},
			},
		},
	},
	{
		Name:        "sentinel_get_patterns",
		Description: "Get learned patterns and project conventions from intent analysis",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"patternType": map[string]interface{}{
					"type":        "string",
					"description": "Filter patterns by type (optional)",
				},
				"limit": map[string]interface{}{
					"type":        "integer",
					"description": "Maximum number of patterns to return (default: 50)",
					"default":     50,
				},
			},
		},
	},
	{
		Name:        "sentinel_get_business_context",
		Description: "Get business rules, entities, and journeys for the project",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"itemType": map[string]interface{}{
					"type":        "string",
					"description": "Filter by knowledge item type: 'rule', 'entity', 'journey' (optional)",
				},
			},
		},
	},
	{
		Name:        "sentinel_get_security_context",
		Description: "Get security rules, compliance status, and security score for the project",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{},
		},
	},
	{
		Name:        "sentinel_get_test_requirements",
		Description: "Get test requirements, coverage status, and missing tests for the project",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"knowledgeItemId": map[string]interface{}{
					"type":        "string",
					"description": "Knowledge item ID to get test requirements for (optional)",
				},
			},
		},
	},
	{
		Name:        "sentinel_check_file_size",
		Description: "Check file size and get warnings and split suggestions",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"filePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to the file to check",
				},
			},
			"required": []string{"filePath"},
		},
	},
	{
		Name:        "sentinel_validate_code",
		Description: "Validate generated code using AST analysis",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"code": map[string]interface{}{
					"type":        "string",
					"description": "Code content to validate",
				},
				"filePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to the file (optional)",
				},
				"language": map[string]interface{}{
					"type":        "string",
					"description": "Programming language (javascript, python, go, etc.)",
				},
			},
			"required": []string{"code"},
		},
	},
	{
		Name:        "sentinel_validate_security",
		Description: "Validate code for security compliance",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"code": map[string]interface{}{
					"type":        "string",
					"description": "Code content to validate",
				},
				"filePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to the file (optional)",
				},
				"language": map[string]interface{}{
					"type":        "string",
					"description": "Programming language",
				},
			},
			"required": []string{"code"},
		},
	},
	{
		Name:        "sentinel_validate_business",
		Description: "Validate code against business rules",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"feature": map[string]interface{}{
					"type":        "string",
					"description": "Feature description",
				},
				"code": map[string]interface{}{
					"type":        "string",
					"description": "Code content to validate",
				},
			},
			"required": []string{"feature", "code"},
		},
	},
	{
		Name:        "sentinel_validate_tests",
		Description: "Validate test quality and coverage",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"testFilePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to the test file",
				},
			},
			"required": []string{"testFilePath"},
		},
	},
	{
		Name:        "sentinel_apply_fix",
		Description: "Apply fixes to code issues",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"filePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to the file to fix",
				},
				"fixType": map[string]interface{}{
					"type":        "string",
					"description": "Type of fix to apply (e.g., 'security', 'style', 'performance')",
				},
			},
			"required": []string{"filePath", "fixType"},
		},
	},
	{
		Name:        "sentinel_generate_tests",
		Description: "Generate test cases for a feature",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"feature": map[string]interface{}{
					"type":        "string",
					"description": "Feature description",
				},
				"code": map[string]interface{}{
					"type":        "string",
					"description": "Code content to generate tests for",
				},
			},
			"required": []string{"feature", "code"},
		},
	},
	{
		Name:        "sentinel_run_tests",
		Description: "Execute tests in sandbox",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"testFilePath": map[string]interface{}{
					"type":        "string",
					"description": "Path to the test file",
				},
				"language": map[string]interface{}{
					"type":        "string",
					"description": "Programming language",
				},
			},
			"required": []string{"testFilePath"},
		},
	},
	{
		Name:        "sentinel_get_task_status",
		Description: "Get task completion status (requires Phase 14E)",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"taskId": map[string]interface{}{
					"type":        "string",
					"description": "Task ID",
				},
				"codebasePath": map[string]interface{}{
					"type":        "string",
					"description": "Optional codebase path for dependency analysis",
				},
			},
			"required": []string{"taskId"},
		},
	},
	{
		Name:        "sentinel_verify_task",
		Description: "Verify task completion (requires Phase 14E)",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"taskId": map[string]interface{}{
					"type":        "string",
					"description": "Task ID",
				},
			},
			"required": []string{"taskId"},
		},
	},
	{
		Name:        "sentinel_list_tasks",
		Description: "List all tasks (requires Phase 14E)",
		InputSchema: map[string]interface{}{
			"type": "object",
			"properties": map[string]interface{}{
				"status": map[string]interface{}{
					"type":        "string",
					"description": "Filter by status (pending, in_progress, completed, blocked)",
				},
				"priority": map[string]interface{}{
					"type":        "string",
					"description": "Filter by priority (low, medium, high, critical)",
				},
				"source": map[string]interface{}{
					"type":        "string",
					"description": "Filter by source (cursor, manual, change_request, comprehensive_analysis)",
				},
				"assigned_to": map[string]interface{}{
					"type":        "string",
					"description": "Filter by assignee",
				},
				"tags": map[string]interface{}{
					"type":        "array",
					"items":       map[string]interface{}{"type": "string"},
					"description": "Filter by tags (array)",
				},
				"include_archived": map[string]interface{}{
					"type":        "boolean",
					"description": "Include archived tasks",
				},
				"limit": map[string]interface{}{
					"type":        "integer",
					"description": "Maximum number of tasks to return (1-100)",
					"minimum":     1,
					"maximum":     100,
				},
				"offset": map[string]interface{}{
					"type":        "integer",
					"description": "Offset for pagination",
					"minimum":     0,
				},
			},
		},
	},
}

// runMCPServer starts the MCP server and handles JSON-RPC 2.0 requests over stdio
func runVersionCheck() {
	fmt.Println("üîç Version Check")
	fmt.Println("================")
	fmt.Println("‚ö†Ô∏è  Version checking is planned for future implementation")
}

func runUpdate() {
	fmt.Println("üì¶ Updating Sentinel")
	fmt.Println("====================")
	fmt.Println("‚ö†Ô∏è  Auto-update is planned for future implementation")
}

func runVersion() {
	fmt.Println("üõ°Ô∏è  Synapse Sentinel v24 (Ultimate)")
}

func runUpdateRules() {
	fmt.Println("üìã Updating Rules")
	fmt.Println("=================")
	fmt.Println("‚ö†Ô∏è  Rules update is planned for future implementation")
}

func runMCPServer() {
	scanner := bufio.NewScanner(os.Stdin)
	encoder := json.NewEncoder(os.Stdout)
	
	// Disable output buffering for stdio
	os.Stdout = os.NewFile(uintptr(syscall.Stdout), "/dev/stdout")
	
	for scanner.Scan() {
		var req MCPRequest
		if err := json.Unmarshal(scanner.Bytes(), &req); err != nil {
			sendMCPError(encoder, nil, ParseErrorCode, "Parse error", err.Error())
			continue
		}
		
		resp := handleMCPRequest(req)
		if err := encoder.Encode(resp); err != nil {
			// Log error to stderr (not stdout) to avoid breaking JSON-RPC protocol
			fmt.Fprintf(os.Stderr, "Failed to encode response: %v\n", err)
		}
	}
	
	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "Scanner error: %v\n", err)
	}
}

// handleMCPRequest routes MCP requests to appropriate handlers
func handleMCPRequest(req MCPRequest) MCPResponse {
	switch req.Method {
	case "initialize":
		return handleInitialize(req)
	case "tools/list":
		return handleToolsList(req)
	case "tools/call":
		return handleToolsCall(req)
	case "notifications/initialized":
		// Acknowledge but no response needed per MCP spec
		return MCPResponse{JSONRPC: "2.0", ID: req.ID, Result: nil}
	default:
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      req.ID,
			Error: &MCPError{
				Code:    MethodNotFoundCode,
				Message: "Method not found",
			},
		}
	}
}

// handleInitialize handles MCP initialize request
func handleInitialize(req MCPRequest) MCPResponse {
	var params InitializeParams
	if len(req.Params) > 0 {
		if err := json.Unmarshal(req.Params, &params); err != nil {
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      req.ID,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    err.Error(),
				},
			}
		}
	}
	
	// Return initialize result
	result := InitializeResult{
		ProtocolVersion: "2024-11-05",
		Capabilities: map[string]interface{}{
			"tools": map[string]interface{}{},
		},
		ServerInfo: map[string]string{
			"name":    "sentinel",
			"version": "v24",
		},
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result:  result,
	}
}

// handleToolsList handles MCP tools/list request
func handleToolsList(req MCPRequest) MCPResponse {
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      req.ID,
		Result: map[string]interface{}{
			"tools": registeredTools,
		},
	}
}

// handleToolsCall handles MCP tools/call request
func handleToolsCall(req MCPRequest) MCPResponse {
	var params ToolCallParams
	if err := json.Unmarshal(req.Params, &params); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      req.ID,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    err.Error(),
			},
		}
	}
	
	switch params.Name {
	case "sentinel_analyze_feature_comprehensive":
		return handleComprehensiveAnalysis(req.ID, params.Arguments)
	case "sentinel_check_intent":
		return handleCheckIntent(req.ID, params.Arguments)
	case "sentinel_get_context":
		return handleGetContext(req.ID, params.Arguments)
	case "sentinel_get_patterns":
		return handleGetPatterns(req.ID, params.Arguments)
	case "sentinel_get_business_context":
		return handleGetBusinessContext(req.ID, params.Arguments)
	case "sentinel_get_security_context":
		return handleGetSecurityContext(req.ID, params.Arguments)
	case "sentinel_get_test_requirements":
		return handleGetTestRequirements(req.ID, params.Arguments)
	case "sentinel_check_file_size":
		return handleCheckFileSize(req.ID, params.Arguments)
	case "sentinel_validate_code":
		return handleValidateCode(req.ID, params.Arguments)
	case "sentinel_validate_security":
		return handleValidateSecurity(req.ID, params.Arguments)
	case "sentinel_validate_business":
		return handleValidateBusiness(req.ID, params.Arguments)
	case "sentinel_validate_tests":
		return handleValidateTests(req.ID, params.Arguments)
	case "sentinel_apply_fix":
		return handleApplyFix(req.ID, params.Arguments)
	case "sentinel_generate_tests":
		return handleGenerateTests(req.ID, params.Arguments)
	case "sentinel_run_tests":
		return handleRunTests(req.ID, params.Arguments)
	case "sentinel_get_task_status":
		return handleGetTaskStatus(req.ID, params.Arguments)
	case "sentinel_verify_task":
		return handleVerifyTask(req.ID, params.Arguments)
	case "sentinel_list_tasks":
		return handleListTasks(req.ID, params.Arguments)
	default:
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      req.ID,
			Error: &MCPError{
				Code:    MethodNotFoundCode,
				Message: "Tool not found",
			},
		}
	}
}

// handleComprehensiveAnalysis handles comprehensive feature analysis tool call
func handleComprehensiveAnalysis(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate and extract parameters
	feature, ok := args["feature"].(string)
	if !ok || feature == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "feature is required and must be a string",
			},
		}
	}
	feature = sanitizeString(feature) // Sanitize feature name (Phase E: Security Hardening)
	
	mode := "auto"
	if m, ok := args["mode"].(string); ok && (m == "auto" || m == "manual") {
		mode = m
	}
	
	depth := "medium"
	if d, ok := args["depth"].(string); ok && (d == "surface" || d == "medium" || d == "deep") {
		depth = d
	}
	
	includeBusinessContext := false
	if ibc, ok := args["includeBusinessContext"].(bool); ok {
		includeBusinessContext = ibc
	}
	
	// 2. Resolve codebase path
	codebasePath := "."
	if cp, ok := args["codebasePath"].(string); ok && cp != "" {
		codebasePath = sanitizePath(cp) // Sanitize path (Phase E: Security Hardening)
		if !isValidPath(codebasePath) { // Validate path
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      id,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    fmt.Sprintf("Invalid codebase path: %s", codebasePath),
				},
			}
		}
	} else {
		// Try to detect from current working directory
		if wd, err := os.Getwd(); err == nil {
			codebasePath = wd
		}
	}
	
	// Validate codebase path exists
	if _, err := os.Stat(codebasePath); os.IsNotExist(err) {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    fmt.Sprintf("codebasePath does not exist: %s", codebasePath),
			},
		}
	}
	
	// 3. Extract files for manual mode
	var files map[string][]string
	if mode == "manual" {
		if f, ok := args["files"].(map[string]interface{}); ok {
			files = make(map[string][]string)
			for layer, fileList := range f {
				if fileArray, ok := fileList.([]interface{}); ok {
					files[layer] = make([]string, len(fileArray))
					for i, file := range fileArray {
						if fileStr, ok := file.(string); ok {
							files[layer][i] = fileStr
						}
					}
				}
			}
		}
	}
	
	// 4. Call Hub API
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	hubRequest := map[string]interface{}{
		"feature":                feature,
		"mode":                   mode,
		"codebasePath":           codebasePath,
		"depth":                  depth,
		"includeBusinessContext": includeBusinessContext,
	}
	if files != nil {
		hubRequest["files"] = files
	}
	
	hubURL := config.HubURL + "/api/v1/analyze/comprehensive"
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	jsonBody, err := json.Marshal(hubRequest)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to marshal request: %v", err),
			},
		}
	}
	
	// 5. Send request to Hub (sendHTTPRequest wraps sendHTTPRequestWithRetry with default retries)
	// Use depth-based timeout for comprehensive analysis
	respBody, statusCode, err := sendComprehensiveAnalysisRequest(hubURL, "POST", headers, jsonBody, depth)
	
	// 6. Handle Hub response
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// Check response size before parsing (10MB limit)
	const maxResponseSize = 10 * 1024 * 1024
	if len(respBody) > maxResponseSize {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Response too large",
				Data:    fmt.Sprintf("Hub response exceeds maximum size (%d bytes). Analysis may be too comprehensive.", maxResponseSize),
			},
		}
	}
	
	// Parse Hub response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	// Validate required fields
	if validationID, ok := hubResponse["validation_id"].(string); !ok || validationID == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Invalid Hub response",
				Data:    "Hub response missing required field: validation_id",
			},
		}
	}
	
	if feature, ok := hubResponse["feature"].(string); !ok || feature == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Invalid Hub response",
				Data:    "Hub response missing required field: feature",
			},
		}
	}
	
	// 7. Format response for Cursor
	result := formatComprehensiveAnalysisResponse(hubResponse)
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result:  result,
	}
}

// formatComprehensiveAnalysisResponse formats Hub API response for Cursor display
func formatComprehensiveAnalysisResponse(hubResponse map[string]interface{}) map[string]interface{} {
	result := map[string]interface{}{
		"validation_id": hubResponse["validation_id"],
		"feature":       hubResponse["feature"],
	}
	
	// Safe summary extraction with defaults
	if summary, ok := hubResponse["summary"].(map[string]interface{}); ok && summary != nil {
		bySeverity := map[string]int{
			"critical": 0,
			"high":     0,
			"medium":   0,
			"low":      0,
		}
		if bs, ok := summary["by_severity"].(map[string]interface{}); ok && bs != nil {
			if c, ok := bs["critical"].(float64); ok {
				bySeverity["critical"] = int(c)
			}
			if h, ok := bs["high"].(float64); ok {
				bySeverity["high"] = int(h)
			}
			if m, ok := bs["medium"].(float64); ok {
				bySeverity["medium"] = int(m)
			}
			if l, ok := bs["low"].(float64); ok {
				bySeverity["low"] = int(l)
			}
		}
		result["summary"] = map[string]interface{}{
			"total_findings": getIntOrDefault(summary["total_findings"], 0),
			"by_severity":    bySeverity,
			"flows_verified": getIntOrDefault(summary["flows_verified"], 0),
			"flows_broken":   getIntOrDefault(summary["flows_broken"], 0),
		}
	} else {
		// Provide default summary if missing
		result["summary"] = map[string]interface{}{
			"total_findings": 0,
			"by_severity":    map[string]int{"critical": 0, "high": 0, "medium": 0, "low": 0},
			"flows_verified": 0,
			"flows_broken":   0,
		}
	}
	
	// Format checklist (prioritized) - safe extraction
	if checklist, ok := hubResponse["checklist"].([]interface{}); ok {
		result["checklist"] = checklist
	}
	
	// Include Hub URL for detailed view - safe extraction
	if hubURL, ok := hubResponse["hub_url"].(string); ok {
		result["hub_url"] = hubURL
	}
	
	// Include layer analysis summary - safe extraction
	if layerAnalysis, ok := hubResponse["layer_analysis"].(map[string]interface{}); ok && layerAnalysis != nil {
		result["layer_summary"] = layerAnalysis
	}
	
	// Include flow status - safe extraction
	if flows, ok := hubResponse["end_to_end_flows"].([]interface{}); ok {
		result["flows"] = flows
	}
	
	return result
}

// handleCheckIntent handles sentinel_check_intent tool call
func handleCheckIntent(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	prompt, ok := args["prompt"].(string)
	if !ok || prompt == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "prompt is required and must be a string",
			},
		}
	}
	
	// 2. Resolve codebase path
	codebasePath := "."
	if cp, ok := args["codebasePath"].(string); ok && cp != "" {
		codebasePath = sanitizePath(cp) // Sanitize path (Phase E: Security Hardening)
		if !isValidPath(codebasePath) {
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      id,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    fmt.Sprintf("Invalid codebase path: %s", codebasePath),
				},
			}
		}
	} else {
		if wd, err := os.Getwd(); err == nil {
			codebasePath = wd
		}
	}
	
	// Sanitize prompt (Phase E: Security Hardening)
	prompt = sanitizeString(prompt)
	
	// 3. Get includeContext flag
	includeContext := true
	if ic, ok := args["includeContext"].(bool); ok {
		includeContext = ic
	}
	
	// 4. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 5. Build request
	hubURL := config.HubURL + "/api/v1/analyze/intent"
	requestBody := map[string]interface{}{
		"prompt":         prompt,
		"codebasePath":   codebasePath,
		"includeContext": includeContext,
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	// 6. Send request with retry
	respBody, statusCode, err := sendHTTPRequest(hubURL, "POST", headers, jsonBody)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 7. Parse and format response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Failed to parse Hub response",
				Data:    err.Error(),
			},
		}
	}
	
	// 8. Format response for Cursor
	result := formatIntentAnalysisResponse(hubResponse)
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result:  result,
	}
}

// formatIntentAnalysisResponse formats Hub response for Cursor display
func formatIntentAnalysisResponse(response map[string]interface{}) map[string]interface{} {
	result := map[string]interface{}{
		"requires_clarification": response["requires_clarification"],
		"intent_type":            response["intent_type"],
		"confidence":             response["confidence"],
	}
	
	if requiresClarification, ok := response["requires_clarification"].(bool); ok && requiresClarification {
		if clarifyingQuestion, ok := response["clarifying_question"].(string); ok {
			result["clarifying_question"] = clarifyingQuestion
		}
		if options, ok := response["options"].([]interface{}); ok && len(options) > 0 {
			result["options"] = options
		}
	} else {
		if suggestedAction, ok := response["suggested_action"].(string); ok && suggestedAction != "" {
			result["suggested_action"] = suggestedAction
		}
		if resolvedPrompt, ok := response["resolved_prompt"].(string); ok && resolvedPrompt != "" {
			result["resolved_prompt"] = resolvedPrompt
		}
	}
	
	return result
}

// handleGetContext handles sentinel_get_context tool call
func handleGetContext(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Resolve codebase path
	codebasePath := "."
	if cp, ok := args["codebasePath"].(string); ok && cp != "" {
		codebasePath = sanitizePath(cp) // Sanitize path (Phase E: Security Hardening)
		if !isValidPath(codebasePath) { // Validate path
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      id,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    fmt.Sprintf("Invalid codebase path: %s", codebasePath),
				},
			}
		}
	} else {
		if wd, err := os.Getwd(); err == nil {
			codebasePath = wd
		}
	}
	
	// 2. Gather git status
	gitStatus := ""
	gitStatusCmd := exec.Command("git", "status", "--porcelain")
	gitStatusCmd.Dir = codebasePath
	if out, err := gitStatusCmd.Output(); err == nil {
		gitStatus = strings.TrimSpace(string(out))
	}
	
	// 3. Get recent commits
	recentCommits := []string{}
	gitLogCmd := exec.Command("git", "log", "-5", "--oneline", "--no-decorate")
	gitLogCmd.Dir = codebasePath
	if out, err := gitLogCmd.Output(); err == nil {
		lines := strings.Split(strings.TrimSpace(string(out)), "\n")
		for _, line := range lines {
			if line != "" {
				recentCommits = append(recentCommits, line)
			}
		}
	}
	
	// 4. Get current branch
	currentBranch := ""
	branchCmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
	branchCmd.Dir = codebasePath
	if out, err := branchCmd.Output(); err == nil {
		currentBranch = strings.TrimSpace(string(out))
	}
	
	// 5. Build response
	contextData := map[string]interface{}{
		"codebasePath":   codebasePath,
		"gitStatus":      gitStatus,
		"recentCommits":  recentCommits,
		"currentBranch":  currentBranch,
		"timestamp":      time.Now().Format(time.RFC3339),
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": fmt.Sprintf("Context for %s:\n\nGit Status:\n%s\n\nCurrent Branch: %s\n\nRecent Commits:\n%s",
						codebasePath,
						gitStatus,
						currentBranch,
						strings.Join(recentCommits, "\n")),
				},
			},
			"data": contextData,
		},
	}
}

// handleGetPatterns handles sentinel_get_patterns tool call
func handleGetPatterns(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 2. Build query parameters
	patternType := ""
	if pt, ok := args["patternType"].(string); ok && pt != "" {
		patternType = sanitizeString(pt) // Sanitize input
	}
	
	limit := 50
	if l, ok := args["limit"].(float64); ok {
		limit = int(l)
	}
	
	// 3. Build URL with proper encoding
	hubURL := config.HubURL + "/api/v1/intent/patterns"
	params := []string{}
	if patternType != "" {
		params = append(params, "type="+url.QueryEscape(patternType)) // URL encode
	}
	if limit != 50 {
		params = append(params, fmt.Sprintf("limit=%d", limit))
	}
	if len(params) > 0 {
		hubURL += "?" + strings.Join(params, "&")
	}
	
	// 4. Send request
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}
	
	respBody, statusCode, err := sendHTTPRequest(endpointURL, "GET", headers, nil)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 5. Parse response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	// 6. Format response
	patterns, _ := hubResponse["patterns"].([]interface{})
	patternsText := "Learned Patterns:\n\n"
	if len(patterns) == 0 {
		patternsText += "No patterns found."
	} else {
		for i, p := range patterns {
			if pMap, ok := p.(map[string]interface{}); ok {
				ptype := ""
				pdata := ""
				freq := float64(0)
				if t, ok := pMap["pattern_type"].(string); ok {
					ptype = t
				}
				if d, ok := pMap["pattern_data"].(string); ok {
					pdata = d
				}
				if f, ok := pMap["frequency"].(float64); ok {
					freq = f
				}
				patternsText += fmt.Sprintf("%d. Type: %s, Frequency: %.0f\n   Data: %s\n\n", i+1, ptype, freq, pdata)
			}
		}
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": patternsText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleGetBusinessContext handles sentinel_get_business_context tool call
func handleGetBusinessContext(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 2. Build query parameters
	itemType := ""
	if it, ok := args["itemType"].(string); ok && it != "" {
		itemType = sanitizeString(it) // Sanitize input
	}
	
	// 3. Build URL with proper encoding
	hubURL := config.HubURL + "/api/v1/knowledge/business"
	if itemType != "" {
		hubURL += "?type=" + url.QueryEscape(itemType) // URL encode parameter
	}
	
	// 4. Send request
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}
	
	respBody, statusCode, err := sendHTTPRequest(endpointURL, "GET", headers, nil)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 5. Parse response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	// 6. Format response
	items, _ := hubResponse["items"].([]interface{})
	contextText := "Business Context:\n\n"
	if len(items) == 0 {
		contextText += "No business context found."
	} else {
		for i, item := range items {
			if itemMap, ok := item.(map[string]interface{}); ok {
				itype := ""
				title := ""
				content := ""
				if t, ok := itemMap["item_type"].(string); ok {
					itype = t
				} else if t, ok := itemMap["type"].(string); ok {
					itype = t
				}
				if ti, ok := itemMap["title"].(string); ok {
					title = ti
				}
				if c, ok := itemMap["content"].(string); ok {
					content = c
					if len(content) > 200 {
						content = content[:200] + "..."
					}
				}
				contextText += fmt.Sprintf("%d. %s: %s\n   %s\n\n", i+1, itype, title, content)
			}
		}
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": contextText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleGetSecurityContext handles sentinel_get_security_context tool call
func handleGetSecurityContext(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 2. Build URL
	hubURL := config.HubURL + "/api/v1/security/context"
	
	// 3. Send request
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}
	
	respBody, statusCode, err := sendHTTPRequest(endpointURL, "GET", headers, nil)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 4. Parse response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	// 5. Format response
	securityText := "Security Context:\n\n"
	
	if score, ok := hubResponse["security_score"].(float64); ok {
		securityText += fmt.Sprintf("Security Score: %.1f/100\n\n", score)
	}
	
	if grade, ok := hubResponse["security_grade"].(string); ok {
		securityText += fmt.Sprintf("Security Grade: %s\n\n", grade)
	}
	
	if rules, ok := hubResponse["rules"].([]interface{}); ok && len(rules) > 0 {
		securityText += "Security Rules:\n"
		for i, rule := range rules {
			if rMap, ok := rule.(map[string]interface{}); ok {
				ruleID := ""
				status := ""
				if id, ok := rMap["rule_id"].(string); ok {
					ruleID = id
				}
				if s, ok := rMap["status"].(string); ok {
					status = s
				}
				securityText += fmt.Sprintf("%d. %s: %s\n", i+1, ruleID, status)
			}
		}
		securityText += "\n"
	}
	
	if compliance, ok := hubResponse["compliance"].(map[string]interface{}); ok {
		securityText += "Compliance Status:\n"
		for key, value := range compliance {
			securityText += fmt.Sprintf("- %s: %v\n", key, value)
		}
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": securityText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleGetTestRequirements handles sentinel_get_test_requirements tool call
func handleGetTestRequirements(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 2. Get knowledge item ID if provided
	knowledgeItemID := ""
	if kid, ok := args["knowledgeItemId"].(string); ok && kid != "" {
		knowledgeItemID = sanitizeString(kid) // Sanitize input
		// Validate it's a valid ID format (alphanumeric, hyphens, underscores)
		if !regexp.MustCompile(`^[a-zA-Z0-9_-]+$`).MatchString(knowledgeItemID) {
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      id,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    "knowledgeItemId contains invalid characters",
				},
			}
		}
	}
	
	// 3. Build URL
	hubURL := config.HubURL + "/api/v1/test-coverage/" + url.PathEscape(knowledgeItemID)
	if knowledgeItemID == "" {
		// If no ID provided, use a different endpoint or return error
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "knowledgeItemId is required",
			},
		}
	}
	
	// 4. Send request
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}
	
	respBody, statusCode, err := sendHTTPRequest(endpointURL, "GET", headers, nil)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 5. Parse response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	// 6. Format response
	requirementsText := "Test Requirements:\n\n"
	if coverage, ok := hubResponse["coverage"].(map[string]interface{}); ok {
		if total, ok := coverage["total_requirements"].(float64); ok {
			requirementsText += fmt.Sprintf("Total Requirements: %.0f\n", total)
		}
		if covered, ok := coverage["covered_requirements"].(float64); ok {
			requirementsText += fmt.Sprintf("Covered Requirements: %.0f\n", covered)
		}
		if missing, ok := coverage["missing_requirements"].(float64); ok {
			requirementsText += fmt.Sprintf("Missing Requirements: %.0f\n", missing)
		}
	}
	
	if requirements, ok := hubResponse["requirements"].([]interface{}); ok && len(requirements) > 0 {
		requirementsText += "\nRequirements:\n"
		for i, req := range requirements {
			if rMap, ok := req.(map[string]interface{}); ok {
				title := ""
				status := ""
				if t, ok := rMap["title"].(string); ok {
					title = t
				}
				if s, ok := rMap["status"].(string); ok {
					status = s
				}
				requirementsText += fmt.Sprintf("%d. %s: %s\n", i+1, title, status)
			}
		}
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": requirementsText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleCheckFileSize handles sentinel_check_file_size tool call
func handleCheckFileSize(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	filePath, ok := args["filePath"].(string)
	if !ok || filePath == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "filePath is required and must be a string",
			},
		}
	}
	
	// Sanitize file path (Phase E: Security Hardening)
	filePath = sanitizePath(filePath)
	if !isValidPath(filePath) {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    fmt.Sprintf("Invalid file path: %s", filePath),
			},
		}
	}
	
	// 2. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 3. Read file content
	fileContent, err := os.ReadFile(filePath)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    fmt.Sprintf("Failed to read file: %v", err),
			},
		}
	}
	
	// 4. Get file info
	fileInfo, err := os.Stat(filePath)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to get file info: %v", err),
			},
		}
	}
	
	// 5. Build request
	hubURL := config.HubURL + "/api/v1/analyze/architecture"
	requestBody := map[string]interface{}{
		"file_path": filePath,
		"file_size": fileInfo.Size(),
		"content":   string(fileContent),
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	// 6. Send request
	respBody, statusCode, err := sendHTTPRequest(hubURL, "POST", headers, jsonBody)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 7. Parse response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	// 8. Format response
	sizeText := fmt.Sprintf("File Size Analysis for %s:\n\n", filePath)
	sizeText += fmt.Sprintf("File Size: %d bytes (%.2f KB)\n\n", fileInfo.Size(), float64(fileInfo.Size())/1024)
	
	if warnings, ok := hubResponse["warnings"].([]interface{}); ok && len(warnings) > 0 {
		sizeText += "Warnings:\n"
		for i, warning := range warnings {
			if wMap, ok := warning.(map[string]interface{}); ok {
				message := ""
				if m, ok := wMap["message"].(string); ok {
					message = m
				}
				sizeText += fmt.Sprintf("%d. %s\n", i+1, message)
			}
		}
		sizeText += "\n"
	}
	
	if suggestions, ok := hubResponse["split_suggestions"].([]interface{}); ok && len(suggestions) > 0 {
		sizeText += "Split Suggestions:\n"
		for i, suggestion := range suggestions {
			if sMap, ok := suggestion.(map[string]interface{}); ok {
				section := ""
				reason := ""
				if sec, ok := sMap["section"].(string); ok {
					section = sec
				}
				if r, ok := sMap["reason"].(string); ok {
					reason = r
				}
				sizeText += fmt.Sprintf("%d. %s: %s\n", i+1, section, reason)
			}
		}
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": sizeText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleValidateCode handles sentinel_validate_code tool call
func handleValidateCode(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	code, ok := args["code"].(string)
	if !ok || code == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "code is required and must be a string",
			},
		}
	}
	
	filePath := ""
	if fp, ok := args["filePath"].(string); ok {
		filePath = sanitizePath(fp) // Sanitize file path (Phase E: Security Hardening)
		if filePath != "" && !isValidPath(filePath) {
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      id,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    fmt.Sprintf("Invalid file path: %s", filePath),
				},
			}
		}
	}
	
	language := ""
	if lang, ok := args["language"].(string); ok {
		language = sanitizeString(lang) // Sanitize language string (Phase E: Security Hardening)
	} else if filePath != "" {
		// Infer language from file extension
		ext := filepath.Ext(filePath)
		langMap := map[string]string{
			".js": "javascript", ".ts": "typescript", ".jsx": "javascript",
			".py": "python", ".go": "go", ".java": "java",
			".cs": "csharp", ".php": "php", ".rb": "ruby",
		}
		if lang, ok := langMap[ext]; ok {
			language = lang
		}
	}
	
	// 2. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 3. Build request
	hubURL := config.HubURL + "/api/v1/validate/code"
	requestBody := map[string]interface{}{
		"code":     code,
		"file_path": filePath,
		"language": language,
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	// 4. Send request
	respBody, statusCode, err := sendHTTPRequest(hubURL, "POST", headers, jsonBody)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 5. Parse and format response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	validationText := "Code Validation Results:\n\n"
	if violations, ok := hubResponse["violations"].([]interface{}); ok && len(violations) > 0 {
		validationText += fmt.Sprintf("Found %d violations:\n\n", len(violations))
		for i, violation := range violations {
			if vMap, ok := violation.(map[string]interface{}); ok {
				rule := ""
				message := ""
				line := float64(0)
				if r, ok := vMap["rule"].(string); ok {
					rule = r
				}
				if m, ok := vMap["message"].(string); ok {
					message = m
				}
				if l, ok := vMap["line"].(float64); ok {
					line = l
				}
				validationText += fmt.Sprintf("%d. Line %.0f: %s - %s\n", i+1, line, rule, message)
			}
		}
	} else {
		validationText += "‚úÖ No violations found. Code is valid."
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": validationText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleValidateSecurity handles sentinel_validate_security tool call
func handleValidateSecurity(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	code, ok := args["code"].(string)
	if !ok || code == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "code is required and must be a string",
			},
		}
	}
	
	// Sanitize code input (Phase E: Security Hardening)
	code = sanitizeString(code)
	
	filePath := ""
	if fp, ok := args["filePath"].(string); ok {
		filePath = sanitizePath(fp) // Sanitize file path
		if filePath != "" && !isValidPath(filePath) {
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      id,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    fmt.Sprintf("Invalid file path: %s", filePath),
				},
			}
		}
	}
	
	language := ""
	if lang, ok := args["language"].(string); ok {
		language = sanitizeString(lang) // Sanitize language string
	} else if filePath != "" {
		ext := filepath.Ext(filePath)
		langMap := map[string]string{
			".js": "javascript", ".ts": "typescript", ".py": "python",
			".go": "go", ".java": "java", ".cs": "csharp",
		}
		if lang, ok := langMap[ext]; ok {
			language = lang
		}
	}
	
	// 2. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 3. Build request (use existing security analysis endpoint)
	hubURL := config.HubURL + "/api/v1/analyze/security"
	requestBody := map[string]interface{}{
		"code":     code,
		"filename": filePath,
		"language": language,
		"rules":    []string{}, // Empty means check all rules
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	// 4. Send request
	respBody, statusCode, err := sendHTTPRequest(hubURL, "POST", headers, jsonBody)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 5. Parse and format response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	securityText := "Security Validation Results:\n\n"
	if score, ok := hubResponse["score"].(float64); ok {
		securityText += fmt.Sprintf("Security Score: %.1f/100\n", score)
	}
	if grade, ok := hubResponse["grade"].(string); ok {
		securityText += fmt.Sprintf("Security Grade: %s\n\n", grade)
	}
	
	if findings, ok := hubResponse["findings"].([]interface{}); ok && len(findings) > 0 {
		securityText += fmt.Sprintf("Found %d security issues:\n\n", len(findings))
		for i, finding := range findings {
			if fMap, ok := finding.(map[string]interface{}); ok {
				rule := ""
				severity := ""
				message := ""
				if r, ok := fMap["rule"].(string); ok {
					rule = r
				}
				if s, ok := fMap["severity"].(string); ok {
					severity = s
				}
				if m, ok := fMap["message"].(string); ok {
					message = m
				}
				securityText += fmt.Sprintf("%d. [%s] %s: %s\n", i+1, severity, rule, message)
			}
		}
	} else {
		securityText += "‚úÖ No security issues found."
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": securityText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleValidateBusiness handles sentinel_validate_business tool call
func handleValidateBusiness(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	feature, ok := args["feature"].(string)
	if !ok || feature == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "feature is required and must be a string",
			},
		}
	}
	
	code, ok := args["code"].(string)
	if !ok || code == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "code is required and must be a string",
			},
		}
	}
	
	// 2. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 3. Build request
	hubURL := config.HubURL + "/api/v1/validate/business"
	requestBody := map[string]interface{}{
		"feature": feature,
		"code":    code,
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	// 4. Send request
	respBody, statusCode, err := sendHTTPRequest(hubURL, "POST", headers, jsonBody)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 5. Parse and format response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	businessText := fmt.Sprintf("Business Rule Validation for: %s\n\n", feature)
	if violations, ok := hubResponse["violations"].([]interface{}); ok && len(violations) > 0 {
		businessText += fmt.Sprintf("Found %d business rule violations:\n\n", len(violations))
		for i, violation := range violations {
			if vMap, ok := violation.(map[string]interface{}); ok {
				rule := ""
				message := ""
				if r, ok := vMap["rule"].(string); ok {
					rule = r
				}
				if m, ok := vMap["message"].(string); ok {
					message = m
				}
				businessText += fmt.Sprintf("%d. %s: %s\n", i+1, rule, message)
			}
		}
	} else {
		businessText += "‚úÖ No business rule violations found."
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": businessText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleValidateTests handles sentinel_validate_tests tool call
func handleValidateTests(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	testFilePath, ok := args["testFilePath"].(string)
	if !ok || testFilePath == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "testFilePath is required and must be a string",
			},
		}
	}
	
	// Sanitize file path (Phase E: Security Hardening)
	testFilePath = sanitizePath(testFilePath)
	if !isValidPath(testFilePath) {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    fmt.Sprintf("Invalid test file path: %s", testFilePath),
			},
		}
	}
	
	// 2. Read test file
	testContent, err := os.ReadFile(testFilePath)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    fmt.Sprintf("Failed to read test file: %v", err),
			},
		}
	}
	
	// 3. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 4. Build request (use existing test validation endpoint)
	hubURL := config.HubURL + "/api/v1/test-validations/validate"
	requestBody := map[string]interface{}{
		"test_file_path": testFilePath,
		"test_content":   string(testContent),
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	// 5. Send request
	respBody, statusCode, err := sendHTTPRequest(hubURL, "POST", headers, jsonBody)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 6. Parse and format response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	testText := fmt.Sprintf("Test Validation Results for: %s\n\n", testFilePath)
	if score, ok := hubResponse["quality_score"].(float64); ok {
		testText += fmt.Sprintf("Quality Score: %.1f/100\n\n", score)
	}
	if coverage, ok := hubResponse["coverage"].(float64); ok {
		testText += fmt.Sprintf("Coverage: %.1f%%\n\n", coverage)
	}
	if issues, ok := hubResponse["issues"].([]interface{}); ok && len(issues) > 0 {
		testText += fmt.Sprintf("Found %d issues:\n\n", len(issues))
		for i, issue := range issues {
			if iMap, ok := issue.(map[string]interface{}); ok {
				issueType := ""
				message := ""
				if t, ok := iMap["type"].(string); ok {
					issueType = t
				}
				if m, ok := iMap["message"].(string); ok {
					message = m
				}
				testText += fmt.Sprintf("%d. [%s] %s\n", i+1, issueType, message)
			}
		}
	} else {
		testText += "‚úÖ No issues found. Tests are valid."
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": testText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleApplyFix handles sentinel_apply_fix tool call
func handleApplyFix(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	filePath, ok := args["filePath"].(string)
	if !ok || filePath == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "filePath is required and must be a string",
			},
		}
	}
	
	// Sanitize file path (Phase E: Security Hardening)
	filePath = sanitizePath(filePath)
	if !isValidPath(filePath) {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    fmt.Sprintf("Invalid file path: %s", filePath),
			},
		}
	}
	
	fixType, ok := args["fixType"].(string)
	if !ok || fixType == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "fixType is required and must be a string",
			},
		}
	}
	
	// Sanitize fix type (Phase E: Security Hardening)
	fixType = sanitizeString(fixType)
	
	// 2. Read file content
	fileContent, err := os.ReadFile(filePath)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    fmt.Sprintf("Failed to read file: %v", err),
			},
		}
	}
	
	// 3. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 4. Build request
	hubURL := config.HubURL + "/api/v1/fixes/apply"
	requestBody := map[string]interface{}{
		"file_path": filePath,
		"fix_type":  fixType,
		"content":   string(fileContent),
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	// 5. Send request
	respBody, statusCode, err := sendHTTPRequest(hubURL, "POST", headers, jsonBody)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 6. Parse and format response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	fixText := fmt.Sprintf("Fix Applied to: %s\n\n", filePath)
	if fixedCode, ok := hubResponse["fixed_code"].(string); ok {
		fixText += "Fixed Code:\n" + fixedCode + "\n\n"
	}
	if changes, ok := hubResponse["changes"].([]interface{}); ok && len(changes) > 0 {
		fixText += fmt.Sprintf("Applied %d changes:\n", len(changes))
		for i, change := range changes {
			if cMap, ok := change.(map[string]interface{}); ok {
				changeType := ""
				description := ""
				if ct, ok := cMap["type"].(string); ok {
					changeType = ct
				}
				if d, ok := cMap["description"].(string); ok {
					description = d
				}
				fixText += fmt.Sprintf("%d. [%s] %s\n", i+1, changeType, description)
			}
		}
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": fixText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleGenerateTests handles sentinel_generate_tests tool call
func handleGenerateTests(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	feature, ok := args["feature"].(string)
	if !ok || feature == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "feature is required and must be a string",
			},
		}
	}
	
	code, ok := args["code"].(string)
	if !ok || code == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "code is required and must be a string",
			},
		}
	}
	
	// Sanitize inputs (Phase E: Security Hardening)
	feature = sanitizeString(feature)
	code = sanitizeString(code)
	
	// 2. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 3. Build request (use existing test requirements generation endpoint)
	hubURL := config.HubURL + "/api/v1/test-requirements/generate"
	requestBody := map[string]interface{}{
		"feature": feature,
		"code":    code,
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	// 4. Send request
	respBody, statusCode, err := sendHTTPRequest(hubURL, "POST", headers, jsonBody)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 5. Parse and format response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	testText := fmt.Sprintf("Generated Tests for: %s\n\n", feature)
	if testCode, ok := hubResponse["test_code"].(string); ok {
		testText += "Test Code:\n" + testCode
	} else if requirements, ok := hubResponse["requirements"].([]interface{}); ok && len(requirements) > 0 {
		testText += fmt.Sprintf("Generated %d test requirements:\n\n", len(requirements))
		for i, req := range requirements {
			if rMap, ok := req.(map[string]interface{}); ok {
				title := ""
				if t, ok := rMap["title"].(string); ok {
					title = t
				}
				testText += fmt.Sprintf("%d. %s\n", i+1, title)
			}
		}
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": testText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleRunTests handles sentinel_run_tests tool call
func handleRunTests(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	testFilePath, ok := args["testFilePath"].(string)
	if !ok || testFilePath == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "testFilePath is required and must be a string",
			},
		}
	}
	
	language := ""
	if lang, ok := args["language"].(string); ok {
		language = lang
	} else {
		// Infer from file extension
		ext := filepath.Ext(testFilePath)
		langMap := map[string]string{
			".js": "javascript", ".ts": "typescript", ".py": "python",
			".go": "go", ".java": "java", ".cs": "csharp",
		}
		if lang, ok := langMap[ext]; ok {
			language = lang
		}
	}
	
	// 2. Read test file
	testContent, err := os.ReadFile(testFilePath)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    fmt.Sprintf("Failed to read test file: %v", err),
			},
		}
	}
	
	// 3. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}
	
	// 4. Build request (use existing test execution endpoint)
	hubURL := config.HubURL + "/api/v1/test-execution/run"
	requestBody := map[string]interface{}{
		"test_file_path": testFilePath,
		"test_content":   string(testContent),
		"language":       language,
	}
	
	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}
	
	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}
	
	// 5. Send request
	respBody, statusCode, err := sendHTTPRequest(hubURL, "POST", headers, jsonBody)
	if err != nil || statusCode != http.StatusOK {
		return handleHubError(err, statusCode, id, config.HubURL)
	}
	
	// 6. Parse and format response
	var hubResponse map[string]interface{}
	if err := json.Unmarshal(respBody, &hubResponse); err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}
	
	testText := fmt.Sprintf("Test Execution Results for: %s\n\n", testFilePath)
	if status, ok := hubResponse["status"].(string); ok {
		testText += fmt.Sprintf("Status: %s\n\n", status)
	}
	if passed, ok := hubResponse["passed"].(float64); ok {
		if failed, ok := hubResponse["failed"].(float64); ok {
			testText += fmt.Sprintf("Passed: %.0f, Failed: %.0f\n\n", passed, failed)
		}
	}
	if coverage, ok := hubResponse["coverage"].(float64); ok {
		testText += fmt.Sprintf("Coverage: %.1f%%\n\n", coverage)
	}
	if output, ok := hubResponse["output"].(string); ok {
		testText += "Output:\n" + output
	}
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": testText,
				},
			},
			"data": hubResponse,
		},
	}
}

// handleGetTaskStatus handles sentinel_get_task_status tool call (Phase 14E)
func handleGetTaskStatus(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	taskID, ok := args["taskId"].(string)
	if !ok || taskID == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "taskId is required and must be a string",
			},
		}
	}

	// Sanitize input
	taskID = sanitizeString(taskID)

	// 2. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}

	// 3. Get task status from Hub
	hubURL := config.HubURL + "/api/v1/tasks/" + taskID
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}

	respBody, statusCode, err := sendHTTPRequest(endpointURL, "GET", headers, nil)
	if err != nil || statusCode != http.StatusOK {
		LogError("Failed to get task status", map[string]interface{}{
			"task_id":     taskID,
			"status_code": statusCode,
			"error":       err,
		})
		return handleHubError(err, statusCode, id, config.HubURL)
	}

	// 4. Parse response
	var task map[string]interface{}
	if err := json.Unmarshal(respBody, &task); err != nil {
		LogError("Failed to parse task response", map[string]interface{}{
			"task_id": taskID,
			"error":   err,
		})
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}

	// 5. Get codebase path (optional)
	codebasePath := "."
	if cp, ok := args["codebasePath"].(string); ok && cp != "" {
		codebasePath = sanitizePath(cp)
		if !isValidPath(codebasePath) {
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      id,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    fmt.Sprintf("Invalid codebase path: %s", codebasePath),
				},
			}
		}
	} else {
		if wd, err := os.Getwd(); err == nil {
			codebasePath = wd
		}
	}

	// 6. Get dependencies (with timeout)
	depsURL := config.HubURL + "/api/v1/tasks/" + taskID + "/dependencies"
	if codebasePath != "." {
		depsURL += "?codebasePath=" + url.QueryEscape(codebasePath)
	}
	depsBody, depsStatus, depsErr := sendHTTPRequestWithTimeout(depsURL, "GET", headers, nil, 3, TaskGetTimeout)
	
	var dependencies map[string]interface{}
	if depsErr == nil && depsStatus == http.StatusOK {
		json.Unmarshal(depsBody, &dependencies)
	}

	// 7. Format response (using safe type assertions)
	status := getString(task, "status", "unknown")
	confidence := getFloat(task, "verification_confidence", 0.0)
	title := getString(task, "title", "")
	priority := getString(task, "priority", "medium")
	filePath := getString(task, "file_path", "")
	lineNumber := getInt(task, "line_number", 0)
	description := getString(task, "description", "")

	statusText := fmt.Sprintf("üìã Task: %s\n\n", title)
	statusText += fmt.Sprintf("üÜî ID: %s\n", taskID)
	statusText += fmt.Sprintf("üìä Status: %s\n", status)
	statusText += fmt.Sprintf("‚≠ê Priority: %s\n", priority)
	statusText += fmt.Sprintf("‚úÖ Verification Confidence: %.0f%%\n", confidence*100)
	
	if filePath != "" {
		statusText += fmt.Sprintf("üìÅ File: %s", filePath)
		if lineNumber > 0 {
			statusText += fmt.Sprintf(":%d", lineNumber)
		}
		statusText += "\n"
	}
	
	if description != "" {
		statusText += fmt.Sprintf("\nüìù Description: %s\n", description)
	}
	
	if dependencies != nil {
		blockedBy, ok := dependencies["blocked_by"].([]interface{})
		if !ok {
			blockedBy = []interface{}{}
		}
		blocks, ok := dependencies["blocks"].([]interface{})
		if !ok {
			blocks = []interface{}{}
		}
		if len(blockedBy) > 0 {
			statusText += fmt.Sprintf("\nüö´ Blocked by: %v\n", blockedBy)
		}
		if len(blocks) > 0 {
			statusText += fmt.Sprintf("üîó Blocks: %v\n", blocks)
		}
	}

	result := map[string]interface{}{
		"content": []map[string]interface{}{
			{
				"type": "text",
				"text": statusText,
			},
		},
		"data": map[string]interface{}{
			"task":        task,
			"dependencies": dependencies,
		},
	}
	
	// Cache the result
	cacheKey := fmt.Sprintf("task_status:%s", taskID)
	setCachedMCPResult(cacheKey, result, 30*time.Second)
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result:  result,
	}
}

// handleVerifyTask handles sentinel_verify_task tool call (Phase 14E)
func handleVerifyTask(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Validate parameters
	taskID, ok := args["taskId"].(string)
	if !ok || taskID == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InvalidParamsCode,
				Message: "Invalid params",
				Data:    "taskId is required and must be a string",
			},
		}
	}

	force := false
	if f, ok := args["force"].(bool); ok {
		force = f
	}

	// Sanitize input
	taskID = sanitizeString(taskID)

	// 2. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}

	// 3. Get codebase path
	codebasePath := "."
	if cp, ok := args["codebasePath"].(string); ok && cp != "" {
		codebasePath = sanitizePath(cp)
		if !isValidPath(codebasePath) {
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      id,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    fmt.Sprintf("Invalid codebase path: %s", codebasePath),
				},
			}
		}
	} else {
		if wd, err := os.Getwd(); err == nil {
			codebasePath = wd
		}
	}

	// 4. Verify task
	hubURL := config.HubURL + "/api/v1/tasks/" + taskID + "/verify?codebasePath=" + url.QueryEscape(codebasePath)
	requestBody := map[string]interface{}{
		"force": force,
	}

	jsonBody, err := json.Marshal(requestBody)
	if err != nil {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to prepare request: %v", err),
			},
		}
	}

	headers := map[string]string{
		"Content-Type":  "application/json",
		"Authorization": "Bearer " + config.APIKey,
	}

	respBody, statusCode, err := sendHTTPRequestWithTimeout(hubURL, "POST", headers, jsonBody, 3, TaskVerifyTimeout)
	if err != nil || statusCode != http.StatusOK {
		LogError("Failed to verify task", map[string]interface{}{
			"task_id":     taskID,
			"status_code": statusCode,
			"error":       err,
		})
		return handleHubError(err, statusCode, id, config.HubURL)
	}

	// 5. Parse response
	var verification map[string]interface{}
	if err := json.Unmarshal(respBody, &verification); err != nil {
		LogError("Failed to parse verification response", map[string]interface{}{
			"task_id": taskID,
			"error":   err,
		})
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}

	// 6. Format response (using safe type assertions)
	confidence := getFloat(verification, "overall_confidence", 0.0)
	status := getString(verification, "status", "unknown")

	verifyText := fmt.Sprintf("üîç Task Verification Results\n\n")
	verifyText += fmt.Sprintf("üÜî Task ID: %s\n", taskID)
	verifyText += fmt.Sprintf("‚úÖ Overall Confidence: %.0f%%\n", confidence*100)
	verifyText += fmt.Sprintf("üìä Status: %s\n\n", status)

	if verifications, ok := verification["verifications"].([]interface{}); ok {
		verifyText += "üìã Verification Factors:\n"
		for _, v := range verifications {
			if vMap, ok := v.(map[string]interface{}); ok {
				vType := getString(vMap, "verification_type", "unknown")
				vStatus := getString(vMap, "status", "unknown")
				vConf := getFloat(vMap, "confidence", 0.0)
				icon := "‚úÖ"
				if vStatus == "failed" {
					icon = "‚ùå"
				} else if vStatus == "pending" {
					icon = "‚è≥"
				}
				verifyText += fmt.Sprintf("  %s %s: %s (%.0f%%)\n", icon, vType, vStatus, vConf*100)
			}
		}
	}

	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result: map[string]interface{}{
			"content": []map[string]interface{}{
				{
					"type": "text",
					"text": verifyText,
				},
			},
			"data": verification,
		},
	}
}

// handleListTasks handles sentinel_list_tasks tool call (Phase 14E)
func handleListTasks(id interface{}, args map[string]interface{}) MCPResponse {
	// 1. Load config
	config := loadConfig()
	if config.HubURL == "" || config.APIKey == "" {
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    ConfigErrorCode,
				Message: "Server error",
				Data:    "Hub not configured. Set SENTINEL_HUB_URL and SENTINEL_API_KEY",
			},
		}
	}

	// 2. Build query parameters
	statusFilter := ""
	if s, ok := args["status"].(string); ok && s != "" {
		statusFilter = sanitizeString(s)
	}

	priorityFilter := ""
	if p, ok := args["priority"].(string); ok && p != "" {
		priorityFilter = sanitizeString(p)
	}

	limit := 50
	if l, ok := args["limit"].(float64); ok {
		limit = int(l)
		if limit > 100 {
			limit = 100
		}
	}

	offset := 0
	if o, ok := args["offset"].(float64); ok {
		offset = int(o)
		if offset < 0 {
			offset = 0
		}
	}

	// 3. Build query parameters for additional filters
	sourceFilter := ""
	if source, ok := args["source"].(string); ok && source != "" {
		sourceFilter = sanitizeString(source)
		validSources := map[string]bool{
			"cursor": true, "manual": true, "change_request": true, "comprehensive_analysis": true,
		}
		if !validSources[sourceFilter] {
			return MCPResponse{
				JSONRPC: "2.0",
				ID:      id,
				Error: &MCPError{
					Code:    InvalidParamsCode,
					Message: "Invalid params",
					Data:    fmt.Sprintf("Invalid source: %s. Must be one of: cursor, manual, change_request, comprehensive_analysis", sourceFilter),
				},
			}
		}
	}

	assignedToFilter := ""
	if assignedTo, ok := args["assigned_to"].(string); ok && assignedTo != "" {
		assignedToFilter = sanitizeString(assignedTo)
	}

	tagsFilter := []string{}
	if tags, ok := args["tags"].([]interface{}); ok && len(tags) > 0 {
		for _, tag := range tags {
			if tagStr, ok := tag.(string); ok && tagStr != "" {
				tagsFilter = append(tagsFilter, sanitizeString(tagStr))
			}
		}
	}

	includeArchived := false
	if ia, ok := args["include_archived"].(bool); ok {
		includeArchived = ia
	}

	// 4. Build URL with all query parameters
	hubURL := config.HubURL + "/api/v1/tasks"
	params := []string{}
	if statusFilter != "" {
		params = append(params, "status="+url.QueryEscape(statusFilter))
	}
	if priorityFilter != "" {
		params = append(params, "priority="+url.QueryEscape(priorityFilter))
	}
	if sourceFilter != "" {
		params = append(params, "source="+url.QueryEscape(sourceFilter))
	}
	if assignedToFilter != "" {
		params = append(params, "assigned_to="+url.QueryEscape(assignedToFilter))
	}
	if len(tagsFilter) > 0 {
		params = append(params, "tags="+url.QueryEscape(strings.Join(tagsFilter, ",")))
	}
	if includeArchived {
		params = append(params, "include_archived=true")
	}
	if limit != 50 {
		params = append(params, fmt.Sprintf("limit=%d", limit))
	}
	if offset > 0 {
		params = append(params, fmt.Sprintf("offset=%d", offset))
	}
	if len(params) > 0 {
		hubURL += "?" + strings.Join(params, "&")
	}

	// 5. Send request
	headers := map[string]string{
		"Authorization": "Bearer " + config.APIKey,
	}

	respBody, statusCode, err := sendHTTPRequestWithTimeout(hubURL, "GET", headers, nil, 3, TaskListTimeout)
	if err != nil || statusCode != http.StatusOK {
		LogError("Failed to list tasks", map[string]interface{}{
			"status_code": statusCode,
			"error":       err,
		})
		return handleHubError(err, statusCode, id, config.HubURL)
	}

	// 6. Parse response
	var response map[string]interface{}
	if err := json.Unmarshal(respBody, &response); err != nil {
		LogError("Failed to parse tasks response", map[string]interface{}{
			"error": err,
		})
		return MCPResponse{
			JSONRPC: "2.0",
			ID:      id,
			Error: &MCPError{
				Code:    InternalErrorCode,
				Message: "Internal error",
				Data:    fmt.Sprintf("Failed to parse Hub response: %v", err),
			},
		}
	}

	// 7. Format response (using safe type assertions)
	var tasks []interface{}
	if t, ok := response["tasks"].([]interface{}); ok {
		tasks = t
	}
	total := getFloat(response, "total", 0.0)

	tasksText := fmt.Sprintf("üìã Tasks (%d total)\n\n", int(total))
	
	if len(tasks) == 0 {
		tasksText += "No tasks found.\n"
	} else {
		for i, taskInterface := range tasks {
			if task, ok := taskInterface.(map[string]interface{}); ok {
				taskID := getString(task, "id", "")
				title := getString(task, "title", "")
				status := getString(task, "status", "unknown")
				priority := getString(task, "priority", "medium")
				confidence := getFloat(task, "verification_confidence", 0.0)
				
				statusIcon := getStatusIcon(status)
				priorityIcon := getPriorityIcon(priority)
				
				tasksText += fmt.Sprintf("%d. %s %s [%s] %s\n", 
					i+1, statusIcon, priorityIcon, status, title)
				tasksText += fmt.Sprintf("   üÜî %s | ‚úÖ %.0f%% confidence\n\n", taskID, confidence*100)
			}
		}
	}

	result := map[string]interface{}{
		"content": []map[string]interface{}{
			{
				"type": "text",
				"text": tasksText,
			},
		},
		"data": response,
	}
	
	// Cache the result
	cacheKey := fmt.Sprintf("list_tasks:%s_%d_%d", statusFilter, limit, offset)
	setCachedMCPResult(cacheKey, result, 10*time.Second)
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Result:  result,
	}
}

// handleHubError categorizes and formats Hub API errors
func handleHubError(err error, statusCode int, id interface{}, hubURL string) MCPResponse {
	var errorCode int
	var errorMessage string
	var errorData interface{}
	
	if err != nil {
		errStr := err.Error()
		if strings.Contains(errStr, "timeout") {
			errorCode = HubTimeoutCode
			errorMessage = "Hub request timeout"
			errorData = map[string]interface{}{
				"fallback": "Analysis timed out. Please try with 'depth: surface' for faster results.",
			}
		} else if strings.Contains(errStr, "connection refused") || 
		          strings.Contains(errStr, "no such host") {
			errorCode = HubUnavailableCode
			errorMessage = "Hub unavailable"
			errorData = map[string]interface{}{
				"fallback":    "Hub is not reachable. Please check SENTINEL_HUB_URL and network connectivity.",
				"suggestion":  "Use Cursor's default analysis or configure Hub connection.",
				"hub_url":     hubURL,
			}
		} else {
			errorCode = InternalErrorCode
			errorMessage = "Internal error"
			errorData = errStr
		}
	} else if statusCode >= 400 && statusCode < 500 {
		errorCode = InvalidParamsCode
		errorMessage = "Invalid request parameters"
		errorData = fmt.Sprintf("Hub returned status %d", statusCode)
	} else if statusCode >= 500 {
		errorCode = HubUnavailableCode
		errorMessage = "Hub server error"
		errorData = fmt.Sprintf("Hub returned status %d", statusCode)
	} else {
		errorCode = InternalErrorCode
		errorMessage = "Internal error"
		errorData = "Unknown error"
	}
	
	// Log detailed error to stderr for debugging
	fmt.Fprintf(os.Stderr, "MCP Hub Error [%d]: %s - %v\n", errorCode, errorMessage, errorData)
	
	return MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Error: &MCPError{
			Code:    errorCode,
			Message: errorMessage,
			Data:    errorData,
		},
	}
}

// sendMCPError is a helper to send MCP error responses
func sendMCPError(encoder *json.Encoder, id interface{}, code int, message string, data interface{}) {
	resp := MCPResponse{
		JSONRPC: "2.0",
		ID:      id,
		Error: &MCPError{
			Code:    code,
			Message: message,
			Data:    data,
		},
	}
	encoder.Encode(resp)
}

// --- UTILS ---

func writeFile(path string, content string) {
	os.WriteFile(path, []byte(content), DefaultFilePerm)
}

func secureGitIgnore() {
	content := "\n# Sentinel Rules\n.cursor/rules/*.md\n!.cursor/rules/00-constitution.md\nsentinel\n"
	f, _ := os.OpenFile(".gitignore", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	f.WriteString(content)
	f.Close()
}

func createCI() {
	// Generates a CI file that runs Sentinel audit
	content := `name: Sentinel Gate
on: [push, pull_request]
jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      - name: Build Sentinel
        run: chmod +x synapsevibsentinel.sh && ./synapsevibsentinel.sh
      - name: Run Audit
        run: ./sentinel audit --ci
        continue-on-error: false
`
	writeFile(".github/workflows/sentinel.yml", content)
}
