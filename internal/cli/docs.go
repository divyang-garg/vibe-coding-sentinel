// Package cli provides docs command implementation
// Complies with CODING_STANDARDS.md: CLI handlers max 300 lines
package cli

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// runDocs executes the docs command
func runDocs(args []string) error {
	outputFile := "docs/FILE_STRUCTURE.md"
	maxDepth := 5

	// Parse flags
	for i, arg := range args {
		switch arg {
		case "--output", "-o":
			if i+1 < len(args) {
				outputFile = args[i+1]
			}
		case "--depth", "-d":
			if i+1 < len(args) {
				fmt.Sscanf(args[i+1], "%d", &maxDepth)
			}
		}
	}

	fmt.Println("üìÅ Generating file structure documentation...")

	// Build file tree
	tree, err := buildFileTree(".", maxDepth)
	if err != nil {
		return fmt.Errorf("unable to scan project files: %w", err)
	}

	// Generate markdown
	content := generateMarkdown(tree)

	// Ensure output directory exists
	dir := filepath.Dir(outputFile)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("unable to create output directory: %w", err)
	}

	// Write file
	if err := os.WriteFile(outputFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("unable to save documentation file: %w", err)
	}

	fmt.Printf("‚úÖ Documentation generated: %s\n", outputFile)
	return nil
}

// FileNode represents a file or directory node
type FileNode struct {
	Name     string
	Path     string
	IsDir    bool
	Children []*FileNode
	Size     int64
}

// buildFileTree recursively builds a file tree
func buildFileTree(root string, maxDepth int) (*FileNode, error) {
	return buildFileTreeRecursive(root, 0, maxDepth)
}

func buildFileTreeRecursive(path string, depth, maxDepth int) (*FileNode, error) {
	if depth > maxDepth {
		return nil, nil
	}

	info, err := os.Stat(path)
	if err != nil {
		return nil, err
	}

	node := &FileNode{
		Name:  filepath.Base(path),
		Path:  path,
		IsDir: info.IsDir(),
		Size:  info.Size(),
	}

	if !info.IsDir() {
		return node, nil
	}

	// Skip certain directories
	if shouldSkipDir(node.Name) {
		return nil, nil
	}

	entries, err := os.ReadDir(path)
	if err != nil {
		return node, nil // Continue even if we can't read directory
	}

	for _, entry := range entries {
		// Skip hidden files and certain patterns
		if strings.HasPrefix(entry.Name(), ".") && entry.Name() != ".cursor" && entry.Name() != ".github" {
			continue
		}

		childPath := filepath.Join(path, entry.Name())
		childNode, err := buildFileTreeRecursive(childPath, depth+1, maxDepth)
		if err != nil || childNode == nil {
			continue
		}

		node.Children = append(node.Children, childNode)
	}

	return node, nil
}

// generateMarkdown generates markdown from file tree
func generateMarkdown(root *FileNode) string {
	var sb strings.Builder

	sb.WriteString("# Project File Structure\n\n")
	sb.WriteString("Auto-generated by Sentinel\n\n")
	sb.WriteString("```\n")

	writeNode(&sb, root, "", true)

	sb.WriteString("```\n")

	return sb.String()
}

// writeNode writes a single node to the string builder
func writeNode(sb *strings.Builder, node *FileNode, prefix string, isLast bool) {
	if node.Name == "." {
		sb.WriteString(".\n")
	} else {
		marker := "‚îú‚îÄ‚îÄ "
		if isLast {
			marker = "‚îî‚îÄ‚îÄ "
		}

		icon := ""
		if node.IsDir {
			icon = "üìÅ "
		} else {
			icon = "üìÑ "
		}

		sb.WriteString(prefix + marker + icon + node.Name + "\n")
	}

	if !node.IsDir {
		return
	}

	// Prepare prefix for children
	childPrefix := prefix
	if node.Name != "." {
		if isLast {
			childPrefix += "    "
		} else {
			childPrefix += "‚îÇ   "
		}
	}

	// Write children
	for i, child := range node.Children {
		writeNode(sb, child, childPrefix, i == len(node.Children)-1)
	}
}

// shouldSkipDir determines if a directory should be skipped
func shouldSkipDir(name string) bool {
	skipDirs := map[string]bool{
		"node_modules": true,
		"vendor":       true,
		"build":        true,
		"dist":         true,
		"target":       true,
		"bin":          true,
		"obj":          true,
		".git":         true,
		".sentinel":    true,
		"__pycache__":  true,
		".next":        true,
		".nuxt":        true,
	}

	return skipDirs[name]
}
